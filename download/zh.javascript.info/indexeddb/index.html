<!DOCTYPE html><html lang="zh" data-theme-enabled="1"><head><script>window.currentUser = null;</script><script>window.rateUsdToNative = 6.3589;</script><title itemprop="name">IndexedDB</title><link href="../pack/styles.e61986aaa5d558f47fd2.css" rel="stylesheet"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes, minimum-scale=1.0"><meta name="apple-mobile-web-app-capable" content="yes"><!-- chrome autotranslate is enabled only for "en" main version--><meta name="google" content="notranslate"><script>if (window.devicePixelRatio > 1) document.cookie = 'pixelRatio=' + window.devicePixelRatio + ';path=/;expires=Tue, 19 Jan 2038 03:14:07 GMT';</script><link href="//fonts.googleapis.com/css?family=Open+Sans:bold,italic,bolditalic" rel="stylesheet"><link rel="apple-touch-icon-precomposed" href="../img/favicon/apple-touch-icon-precomposed.png"><link rel="canonical" href="https://zh.javascript.info/indexeddb"><meta name="msapplication-TileColor" content="#222A2C"><meta name="msapplication-TileImage" content="/img/favicon/tileicon.png"><link rel="icon" href="../img/favicon/favicon.png"><meta itemprop="image" content="https://zh.javascript.info/img/site_preview_en_512x512.png"><meta property="og:title" content="IndexedDB"><meta property="og:image" content="../img/site_preview_en_1200x630.png"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta property="fb:admins" content="100001562528165"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="IndexedDB"><meta name="twitter:site" content="@iliakan"><meta name="twitter:creator" content="@iliakan"><meta name="twitter:image" content="https://zh.javascript.info/img/site_preview_en_512x512.png"><link rel="prev" href="/localstorage"><link rel="next" href="/animation"><script>window.GA_ID = "UA-2056213-15";</script><script>window.YANDEX_METRIKA_ID = 65598091;</script><script>window.GoogleAnalyticsObject="ga",window.ga=function(){window.ga.q.push(arguments)},window.ga.q=[],window.ga.l=Date.now(),ga("create",GA_ID,"auto"),window.GTM_ID&&ga("require",GTM_ID),window.currentUser?ga("set","&uid",currentUser.id):ga("set","anonymizeIp",!0),window.addEventListener("error",function(e){var r=(e.filename||e.errorUrl)+": "+(e.lineno||e.errorLine),n=e.stack||e.error&&e.error.stack;ga("send","exception",{exDescription:e.message+" "+r+" "+n,exFatal:!0})});</script><script src="https://www.google-analytics.com/analytics.js" async></script><script>ga('send', 'pageview');</script><script>window.metrika={reachGoal:function(){}},window.yandex_metrika_callbacks=[function(){try{window.metrika=new Ya.Metrika({id:YANDEX_METRIKA_ID,webvisor:!0,clickmap:!0,params:{user:window.currentUser&&window.currentUser.id}}),metrika.trackLinks({delay:150}),window.addEventListener("error",function(r){window.metrika.reachGoal("JSERROR",{src:(r.filename||r.errorUrl)+": "+(r.lineno||r.errorLine),stack:r.stack||r.error&&r.error.stack,message:r.message})})}catch(r){}}];</script><script src="//mc.yandex.ru/metrika/watch.js" async></script><script>window.RECAPTCHA_ID = "6LfmLAEVAAAAAJMykMnf7aY8nkyTRmYi2ynx51R1";</script><script src="../pack/init.f551d10c469632252be6.js"></script><script src="../pack/head.7c4dbce7f0d4e5d1865e.js" defer></script><script src="https://cdn.jsdelivr.net/npm/idb@3.0.2/build/idb.min.js"></script><meta property="og:title" content="IndexedDB"><meta property="og:type" content="article"><script src="../pack/tutorial.0085805d53a665cf3a7e.js" defer></script><script src="../pack/footer.b5edaae5b6e4efe79394.js" defer></script></head><body class="no-icons"><script>window.fontTest();</script><div class="page-wrapper page-wrapper_sidebar_on"><!--[if IE]><div style="color:red;text-align:center">很抱歉，我们不支持 Internet Explorer 等浏览器，请使用一个更新版本的浏览器。</div><![endif]--><div class="sitetoolbar sitetoolbar_tutorial"><script>window.langs = [{"code":"ar","name":"Arabic"},{"code":"az","name":"Azerbaijani"},{"code":"bg","name":"Bulgarian"},{"code":"bn","name":"Bengali"},{"code":"bs","name":"Bosnian"},{"code":"ca","name":"Catalan"},{"code":"cs","name":"Czech"},{"code":"da","name":"Danish"},{"code":"de","name":"German"},{"code":"el","name":"Greek"},{"code":"en","name":"English"},{"code":"es","name":"Spanish"},{"code":"fa","name":"Persian (Farsi)"},{"code":"fi","name":"Finnish"},{"code":"fr","name":"French"},{"code":"he","name":"Hebrew"},{"code":"hi","name":"Hindi"},{"code":"hr","name":"Croatian"},{"code":"hu","name":"Hungarian"},{"code":"hy","name":"Armenian"},{"code":"id","name":"Indonesian"},{"code":"it","name":"Italian"},{"code":"ja","name":"Japanese"},{"code":"ka","name":"Georgian"},{"code":"kk","name":"Kazakh"},{"code":"km","name":"Central Khmer"},{"code":"ko","name":"Korean"},{"code":"lt","name":"Lithuanian"},{"code":"me","name":"Montenegrin"},{"code":"ml","name":"Malayalam"},{"code":"my","name":"Burmese"},{"code":"nl","name":"Dutch"},{"code":"no","name":"Norvegian"},{"code":"pa","name":"Punjabi"},{"code":"pl","name":"Polish"},{"code":"pt","name":"Portuguese"},{"code":"ro","name":"Romanian"},{"code":"ru","name":"Russian"},{"code":"si","name":"Sinhala"},{"code":"sk","name":"Slovak"},{"code":"sl","name":"Slovenian"},{"code":"sq","name":"Albanian"},{"code":"sr","name":"Serbian"},{"code":"ta","name":"Tamil"},{"code":"te","name":"Telugu"},{"code":"test","name":"Test"},{"code":"th","name":"Thai"},{"code":"tk","name":"Turkmen"},{"code":"tr","name":"Turkish"},{"code":"uk","name":"Ukrainian"},{"code":"ur","name":"Urdu"},{"code":"uz","name":"Uzbek"},{"code":"v2","name":"v2"},{"code":"vi","name":"Vietnamese"},{"code":"zh-hant","name":"Chinese Traditional"},{"code":"zh","name":"Chinese"}];</script><script>window.lang = "zh";</script><script>{let t=navigator.languages||[];t=t.map(t=>t.toLowerCase());let o,i,n=[];for(let o of window.langs)for(let i of t)if(i===o.code||i.startsWith(o.code+"-")){n.push(o);break}if(!o&&"ru"!=lang&&"en"!=lang){n.find(t=>"en"==t.code)&&(o=`\n            According to your browser headers, you know English. Please help to <a href="https://github.com/javascript-tutorial/${lang}.javascript.info#readme">translate the tutorial</a>.\n            Thank you!\n          `,i="notify-translate-tutorial-local")}if(o){let t=`<div class="notification notification_top notification_info sitetoolbar__notification" style="display:none" id="${i}">\n          <div class="notification__content">${o}</div>\n          <button class="notification__close" title="Close"></button>\n        </div>`;document.write(t),showTopNotification()}}</script><div class="sitetoolbar__content"><div class="sitetoolbar__lang-switcher"><button class="sitetoolbar__dropdown-button" data-dropdown-toggler>ZH</button><div class="sitetoolbar__dropdown-wrap"><div class="sitetoolbar__dropdown-body"><div class="sitetoolbar__lang-switcher-body"><div class="supported-langs supported-langs_toolbar"><div class="supported-langs__container"><ul class="supported-langs__list" style="height:200px"><li class="supported-langs__item"><a class="supported-langs__link" href="https://ar.javascript.info/"><span class="supported-langs__brief">AR</span><span class="supported-langs__title">عربي</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://javascript.info/indexeddb"><span class="supported-langs__brief">EN</span><span class="supported-langs__title">English</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://es.javascript.info/indexeddb"><span class="supported-langs__brief">ES</span><span class="supported-langs__title">Español</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://fr.javascript.info/"><span class="supported-langs__brief">FR</span><span class="supported-langs__title">Français</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://id.javascript.info/"><span class="supported-langs__brief">ID</span><span class="supported-langs__title">Indonesia</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://it.javascript.info/"><span class="supported-langs__brief">IT</span><span class="supported-langs__title">Italiano</span></a></li></ul><ul class="supported-langs__list" style="height:200px"><li class="supported-langs__item"><a class="supported-langs__link" href="https://ja.javascript.info/indexeddb"><span class="supported-langs__brief">JA</span><span class="supported-langs__title">日本語</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://ko.javascript.info/"><span class="supported-langs__brief">KO</span><span class="supported-langs__title">한국어</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://learn.javascript.ru/indexeddb"><span class="supported-langs__brief">RU</span><span class="supported-langs__title">Русский</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://tr.javascript.info/indexeddb"><span class="supported-langs__brief">TR</span><span class="supported-langs__title">Türkçe</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://uk.javascript.info/"><span class="supported-langs__brief">UK</span><span class="supported-langs__title">Українська</span></a></li><li class="supported-langs__item supported-langs__item_current"><a class="supported-langs__link" href="index.html"><span class="supported-langs__brief">ZH</span><span class="supported-langs__title">简体中文</span></a></li></ul></div><div class="supported-langs__text">我们希望将这个开源项目提供给全世界的人。请帮助我们将教程的内容 <a href="https://github.com/javascript-tutorial/translate" rel="noopener noreferrer" target="_blank">翻译为你所掌握的语言</a> 对应的版本。</div></div></div></div></div></div><div class="sitetoolbar__logo-wrap"><a class="sitetoolbar__link sitetoolbar__link_logo" href="../index.html"><img class="sitetoolbar__logo sitetoolbar__logo_normal" src="../img/sitetoolbar__logo_en.svg" width="200" alt role="presentation"><img class="sitetoolbar__logo sitetoolbar__logo_normal sitetoolbar__logo_dark" src="../img/sitetoolbar__logo_en-white.svg" width="200" alt role="presentation"><img class="sitetoolbar__logo sitetoolbar__logo_small" src="../img/sitetoolbar__logo_small_en.svg" width="70" alt role="presentation"><img class="sitetoolbar__logo sitetoolbar__logo_small sitetoolbar__logo_dark" src="../img/sitetoolbar__logo_small_en-white.svg" width="70" alt role="presentation"><script>Array.prototype.forEach.call(document.querySelectorAll("img.sitetoolbar__logo"),function(e){let t=document.createElement("object");t.type="image/svg+xml",t.className=e.className,t.style.cssText="left:0;top:0;position:absolute",t.onload=function(){t.onload=null,e.style.visibility="hidden"},t.data=e.src,e.parentNode.insertBefore(t,e)});</script></a></div><div class="sitetoolbar__nav-toggle-wrap"><button class="sitetoolbar__nav-toggle" type="button"></button></div><nav class="sitetoolbar__sections"><ul class="sitetoolbar__sections-list"></ul></nav><div class="sitetoolbar__book-wrap"><a class="buy-book-button" href="../ebook/index.html"><span class="buy-book-button__extra-text">购买</span>EPUB/PDF</a></div><div class="sitetoolbar__theme-switcher"><div class="theme-changer"><label class="theme-changer__label" for="theme-changer-input" data-tooltip="Change theme"><input class="theme-changer__input" type="checkbox" id="theme-changer-input" data-theme-changer="data-theme-changer"><span class="theme-changer__icon theme-changer__icon_light-theme"></span><span class="theme-changer__icon theme-changer__icon_dark-theme"></span></label></div></div><div class="sitetoolbar__search-wrap"><div class="sitetoolbar__search-content"><button class="sitetoolbar__search-toggle" type="button"></button><form class="sitetoolbar__search" method="GET" action="/search"><div class="sitetoolbar__search-input"><div class="text-input"><input class="text-input__control" name="query" placeholder="在 Javascript.info 网站中搜索" required="required" type="text"></div><button class="sitetoolbar__find" type="submit">搜索</button></div></form></div></div></div><div class="tablet-menu"><div class="tablet-menu__line"><div class="tablet-menu__content"><form class="tablet-menu-search" action="/search/"><input class="tablet-menu-search__input" type="search" name="query" placeholder="在教程中搜索" required="required"><button class="tablet-menu-search__button" type="submit" name="type" value="articles">搜索</button></form></div></div><div class="tablet-menu__line"><div class="tablet-menu__content"><a class="map" href="../tutorial/map/index.html" data-action="tutorial-map"><span class="map__text">教程路线图</span></a></div></div><div class="tablet-menu__line"><div class="tablet-menu__content"><div class="theme-changer theme-changer_tablet-menu theme-changer_has-label"><label class="theme-changer__label" for="theme-changer-input-tablet" data-tooltip="Change theme"><input class="theme-changer__input" type="checkbox" id="theme-changer-input-tablet" data-theme-changer="data-theme-changer"><span class="theme-changer__icon theme-changer__icon_light-theme"></span><span class="theme-changer__icon theme-changer__icon_dark-theme"></span><span class="theme-changer__label-text theme-changer__label-text_light-theme">Light theme</span><span class="theme-changer__label-text theme-changer__label-text_dark-theme">Dark theme</span></label></div></div></div><div class="tablet-menu__line"><div class="tablet-menu__content"><div class="share-icons"><span class="share-icons__title">分享</span><a class="share share_tw" href="https://twitter.com/share?url=https%3A%2F%2Fzh.javascript.info%2Findexeddb" rel="nofollow"></a><a class="share share_fb" href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fzh.javascript.info%2Findexeddb" rel="nofollow"></a></div></div></div><div class="tablet-menu__line"><div class="tablet-menu__content"><select class="tablet-menu__nav input-select input-select input-select_small" onchange="if(this.value) window.location.href=this.value"><option value="https://ar.javascript.info/">عربي</option><option value="https://javascript.info/indexeddb">English</option><option value="https://es.javascript.info/indexeddb">Español</option><option value="https://fr.javascript.info/">Français</option><option value="https://id.javascript.info/">Indonesia</option><option value="https://it.javascript.info/">Italiano</option><option value="https://ja.javascript.info/indexeddb">日本語</option><option value="https://ko.javascript.info/">한국어</option><option value="https://learn.javascript.ru/indexeddb">Русский</option><option value="https://tr.javascript.info/indexeddb">Türkçe</option><option value="https://uk.javascript.info/">Українська</option><option value="https://zh.javascript.info/indexeddb" selected>简体中文</option></select></div></div></div><progress class="tutorial-progress" data-sticky value="3" max="3" data-tooltip="第 3/3 节"></progress></div><div class="page page_sidebar_on page_inner_padding"><script>if(localStorage.noSidebar){document.querySelector(".page").classList.remove("page_sidebar_on");let e=document.querySelector(".page-wrapper");e&&e.classList.remove("page-wrapper_sidebar_on")}setTimeout(function(){document.querySelector(".page").classList.add("page_sidebar-animation-on")});</script><div class="page__inner"><main class="main main_width-limit"><header class="main__header"><div class="main__header-inner"><div class="main__header-group"><ol class="breadcrumbs"><li class="breadcrumbs__item breadcrumbs__item_home"><a class="breadcrumbs__link" href="../index.html"><span class="breadcrumbs__hidden-text">教程</span></a></li><li class="breadcrumbs__item" id="breadcrumb-1"><a class="breadcrumbs__link" href="../data-storage/index.html"><span>在浏览器中存储数据</span></a></li><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"教程","item":"https://zh.javascript.info/"},{"@type":"ListItem","position":2,"name":"在浏览器中存储数据","item":"https://zh.javascript.info/data-storage"}]}</script></ol><div class="updated-at" data-tooltip="最后修改在 15日 十二月 2021"><div class="updated-at__content">15日 十二月 2021</div></div></div><h1 class="main__header-title">IndexedDB</h1></div></header><div class="content"><article class="formatted" itemscope itemtype="http://schema.org/TechArticle"><meta itemprop="name" content="IndexedDB"><div itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="email" content="iliakan@gmail.com"><meta itemprop="name" content="Ilya Kantor"></div><div itemprop="articleBody"><p>IndexedDB 是一个浏览器内建的数据库，它比 <code>localStorage</code> 强大得多。</p>
<ul>
<li>通过支持多种类型的键，来存储几乎可以是任何类型的值。</li>
<li>支撑事务的可靠性。</li>
<li>支持键范围查询、索引。</li>
<li>和 <code>localStorage</code> 相比，它可以存储更大的数据量。</li>
</ul>
<p>对于传统的 客户端-服务器 应用，这些功能通常是没有必要的。IndexedDB 适用于离线应用，可与 ServiceWorkers 和其他技术相结合使用。</p>
<p>根据规范 <a href="https://www.w3.org/TR/IndexedDB">https://www.w3.org/TR/IndexedDB</a> 中的描述，IndexedDB 的本机接口是基于事件的。</p>
<p>我们还可以在基于 promise 的包装器（wrapper），如 <a href="https://github.com/jakearchibald/idb">https://github.com/jakearchibald/idb</a> 的帮助下使用 <code>async/await</code>。这要方便的多，但是包装器并不完美，它并不能替代所有情况下的事件。因此，我们先练习事件（events），在理解了 IndexedDB 之后，我们将使用包装器。</p>
<h2><a class="main__anchor" name="da-kai-shu-ju-ku" href="#da-kai-shu-ju-ku">打开数据库</a></h2><p>要想使用 IndexedDB，首先需要 <code>open</code>（连接）一个数据库。</p>
<p>语法：</p>
<div id="83jkrn5r01" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let openRequest = indexedDB.open(name, version);</code></pre>
        </div>
      </div>
      
      </div><ul>
<li><code>name</code> —— 字符串，即数据库名称。</li>
<li><code>version</code> —— 一个正整数版本，默认为 <code>1</code>（下面解释）。</li>
</ul>
<p>数据库可以有许多不同的名称，但是必须存在于当前的源（域/协议/端口）中。不同的网站不能相互访问对方的数据库。</p>
<p>调用之后会返回 <code>openRequest</code> 对象，我们需要监听该对象上的事件：</p>
<ul>
<li><code>success</code>：数据库准备就绪，<code>openRequest.result</code> 中有了一个数据库对象“Database Object”，使用它进行进一步的调用。</li>
<li><code>error</code>：打开失败。</li>
<li><code>upgradeneeded</code>：数据库已准备就绪，但其版本已过时（见下文）。</li>
</ul>
<p><strong>IndexedDB 具有内建的“模式（scheme）版本控制”机制，这在服务器端数据库中是不存在的。</strong></p>
<p>与服务器端数据库不同，IndexedDB 存在于客户端，数据存储在浏览器中。因此，开发人员无法随时都能访问它。因此，当我们发布了新版本的应用程序，用户访问我们的网页，我们可能需要更新该数据库。</p>
<p>如果本地数据库版本低于 <code>open</code> 中指定的版本，会触发一个特殊事件 <code>upgradeneeded</code>。我们可以根据需要比较版本并升级数据结构。</p>
<p>当数据库还不存在时（从技术上讲，该版本为 <code>0</code>），也会触发 <code>upgradeneeded</code> 事件。因此，我们可以执行初始化。</p>
<p>假设我们发布了应用程序的第一个版本。</p>
<p>接下来我们就可以打开版本 <code>1</code> 中的 IndexedDB 数据库，并在一个 <code>upgradeneeded</code> 的处理程序中执行初始化，如下所示：</p>
<div id="gacd6b3fgi" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:0,&quot;cols&quot;:[{&quot;start&quot;:42,&quot;end&quot;:43}]}]">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let openRequest = indexedDB.open(&quot;store&quot;, 1);

openRequest.onupgradeneeded = function() {
  // 如果客户端没有数据库则触发
  // ...执行初始化...
};

openRequest.onerror = function() {
  console.error(&quot;Error&quot;, openRequest.error);
};

openRequest.onsuccess = function() {
  let db = openRequest.result;
  // 继续使用 db 对象处理数据库
};</code></pre>
        </div>
      </div>
      
      </div><p>之后不久，我们发布了第二个版本。</p>
<p>我们可以打开版本 <code>2</code> 中的 IndexedDB 数据库，并像这样进行升级：</p>
<div id="ak4dfo9ezm" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:0,&quot;cols&quot;:[{&quot;start&quot;:42,&quot;end&quot;:43}]}]">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let openRequest = indexedDB.open(&quot;store&quot;, 2);

openRequest.onupgradeneeded = function(event) {
  // 现有的数据库版本小于 2（或不存在）
  let db = openRequest.result;
  switch(event.oldVersion) { // 现有的 db 版本
    case 0:
      // 版本 0 表示客户端没有数据库
      // 执行初始化
    case 1:
      // 客户端版本为 1
      // 更新
  }
};</code></pre>
        </div>
      </div>
      
      </div><p>请注意：虽然我们目前的版本是 <code>2</code>，<code>onupgradeneeded</code> 处理程序有针对版本 <code>0</code> 的代码分支（适用于初次访问，浏览器中没有数据库的用户）和针对版本 <code>1</code> 的代码分支（用于升级）。</p>
<p>接下来，当且仅当 <code>onupgradeneeded</code> 处理程序没有错误地执行完成，<code>openRequest.onsuccess</code> 被触发，数据库才算是成功打开了。</p>
<p>删除数据库：</p>
<div id="zu3wqr2nij" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let deleteRequest = indexedDB.deleteDatabase(name)
// deleteRequest.onsuccess/onerror 追踪（tracks）结果</code></pre>
        </div>
      </div>
      
      </div><div class="important important_warn">
            <div class="important__header"><span class="important__type">我们无法打开旧版本的数据库</span></div>
            <div class="important__content"><p>如果当前用户的数据库版本比 <code>open</code> 调用的版本更高（比如当前的数据库版本为 <code>3</code>，我们却尝试运行 <code>open(...2)</code>，就会产生错误并触发 <code>openRequest.onerror</code>）。</p>
<p>这很罕见，但这样的事情可能会在用户加载了一个过时的 JavaScript 代码时发生（例如用户从一个代理缓存中加载 JS）。在这种情况下，代码是过时的，但数据库却是最新的。</p>
<p>为了避免这样的错误产生，我们应当检查 <code>db.version</code> 并建议用户重新加载页面。使用正确的 HTTP 缓存头（header）来避免之前缓存的旧代码被加载，这样你就永远不会遇到此类问题。</p>
</div></div>
<h3><a class="main__anchor" name="bing-hang-geng-xin-wen-ti" href="#bing-hang-geng-xin-wen-ti">并行更新问题</a></h3><p>提到版本控制，有一个相关的小问题。</p>
<p>举个例子：</p>
<ol>
<li>一个用户在一个浏览器标签页中打开了数据库版本为 <code>1</code> 的我们的网站。</li>
<li>接下来我们发布了一个更新，使得代码更新了。</li>
<li>接下来同一个用户在另一个浏览器标签中打开了这个网站。</li>
</ol>
<p>这时，有一个标签页和版本为 <code>1</code> 的数据库建立了一个连接，而另一个标签页试图在其 <code>upgradeneeded</code> 处理程序中将数据库版本升级到 <code>2</code>。</p>
<p>问题是，这两个网页是同一个站点，同一个源，共享同一个数据库。而数据库不能同时为版本 <code>1</code> 和版本 <code>2</code>。要执行版本 <code>2</code> 的更新，必须关闭对版本 <code>1</code> 的所有连接，包括第一个标签页中的那个。</p>
<p>为了解决这一问题，<code>versionchange</code> 事件会在“过时的”数据库对象上触发。我们需要监听这个事件，关闭对旧版本数据库的连接（还应该建议访问者重新加载页面，以加载最新的代码）。</p>
<p>如果我们不监听 <code>versionchange</code> 事件，也不去关闭旧连接，那么新的连接就不会建立。<code>openRequest</code> 对象会产生 <code>blocked</code> 事件，而不是 <code>success</code> 事件。因此第二个标签页无法正常工作。</p>
<p>下面是能够正确处理并行升级情况的代码。</p>
<p>在数据库被打开后，它将注入一个用于关闭旧连接的 <code>onversionchange</code> 处理程序：</p>
<div id="7h9m3ggogu" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:16,&quot;end&quot;:21},{&quot;start&quot;:8,&quot;end&quot;:11}]">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let openRequest = indexedDB.open(&quot;store&quot;, 2);

openRequest.onupgradeneeded = ...;
openRequest.onerror = ...;

openRequest.onsuccess = function() {
  let db = openRequest.result;

  db.onversionchange = function() {
    db.close();
    alert(&quot;Database is outdated, please reload the page.&quot;)
  };

  // ……数据库已经准备好，请使用它……
};

openRequest.onblocked = function() {
  // 如果我们正确处理了 onversionchange 事件，这个事件就不应该触发

  // 这意味着还有另一个指向同一数据库的连接
  // 并且在 db.onversionchange 被触发后，该连接没有被关闭
};</code></pre>
        </div>
      </div>
      
      </div><p>在这我们做两件事：</p>
<ol>
<li>成功打开后添加 <code>db.onversionchange</code> 监听器，以得到尝试并行更新的消息。</li>
<li>添加 <code>openRequest.onblocked</code> 监听器来处理旧连接未关闭的情况。如果在 <code>db.onversionchange</code> 中关闭，就不会发生这种情况。</li>
</ol>
<p>还有其他方案。例如，我们可以在 <code>db.onversionchange</code> 中更优雅地关闭连接，关闭连接之前提示用户保存数据。如果 <code>db.onversionchange</code> 已完成但旧的连接没有被关闭，新的连接将被立即阻塞，那么我们可以在新的标签页中要求用户关闭其他标签页以更新数据。</p>
<p>这种更新冲突很少发生，但我们至少应该有一些对其进行处理的程序，例如 <code>onblocked</code> 处理程序，以防程序默默卡死而影响用户体验。</p>
<h2><a class="main__anchor" name="dui-xiang-ku-objectstore" href="#dui-xiang-ku-objectstore">对象库（object store）</a></h2><p>要在 <code>IndexedDB</code> 中存储某些内容，我们需要一个 <strong>对象库</strong>。</p>
<p>对象库是 IndexedDB 的核心概念，在其他数据库中对应的对象称为“表”或“集合”。它是储存数据的地方。一个数据库可能有多个存储区：一个用于存储用户数据，另一个用于商品，等等。</p>
<p>尽管被命名为“对象库”，但也可以存储原始类型。</p>
<p><strong>几乎可以存储任何值，包括复杂的对象。</strong></p>
<p>IndexedDB 使用 <a href="https://www.w3.org/TR/html53/infrastructure.html#section-structuredserializeforstorage">标准序列化算法</a> 来克隆和存储对象。类似于 <code>JSON.stringify</code>，不过功能更加强大，能够存储更多的数据类型。</p>
<p>有一种对象不能被存储：循环引用的对象。此类对象不可序列化，也不能进行 <code>JSON.stringify</code>。</p>
<p><strong>库中的每个值都必须有唯一的键 <code>key</code>。</strong></p>
<p>键的类型必须为数字、日期、字符串、二进制或数组。它是唯一的标识符，所以我们可以通过键来搜索/删除/更新值。</p>
<figure><div class="image" style="width:484px">
      <div class="image__ratio" style="padding-top:55.16528925619835%"></div>
      <object type="image/svg+xml" data="../article/indexeddb/indexeddb-structure.svg" width="484" height="267" class="image__image" data-use-theme>
        <img src="../article/indexeddb/indexeddb-structure.svg" alt width="484" height="267">
      </object>
      </div></figure><p>类似于 <code>localStorage</code>，我们向存储区添加值时，可以提供一个键。但当我们存储对象时，IndexedDB 允许将一个对象属性设置为键，这就更加方便了。或者，我们可以自动生成键。</p>
<p>但我们需要先创建一个对象库。</p>
<p>创建对象库的语法：</p>
<div id="11geb54np9" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>db.createObjectStore(name[, keyOptions]);</code></pre>
        </div>
      </div>
      
      </div><p>请注意，操作是同步的，不需要 <code>await</code>。</p>
<ul>
<li><code>name</code> 是存储区名称，例如 <code>&quot;books&quot;</code> 表示书。</li>
<li><code>keyOptions</code> 是具有以下两个属性之一的可选对象：
<ul>
<li><code>keyPath</code> —— 对象属性的路径，IndexedDB 将以此路径作为键，例如 <code>id</code>。</li>
<li><code>autoIncrement</code> —— 如果为 <code>true</code>，则自动生成新存储的对象的键，键是一个不断递增的数字。</li>
</ul>
</li>
</ul>
<p>如果我们不提供 <code>keyOptions</code>，那么以后需要在存储对象时，显式地提供一个键。</p>
<p>例如，此对象库使用 <code>id</code> 属性作为键:</p>
<div id="axhh9ok1gu" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>db.createObjectStore('books', {keyPath: 'id'});</code></pre>
        </div>
      </div>
      
      </div><p><strong>在 <code>upgradeneeded</code> 处理程序中，只有在创建数据库版本时，对象库被才能被 创建/修改。</strong></p>
<p>这是技术上的限制。在 upgradeneedHandler 之外，可以添加/删除/更新数据，但是只能在版本更新期间创建/删除/更改对象库。</p>
<p>要进行数据库版本升级，主要有两种方法：</p>
<ol>
<li>我们实现每个版本的升级功能：从 1 到 2，从 2 到 3，从 3 到 4，等等。在 <code>upgradeneeded</code> 中，可以进行版本比较（例如，老版本是 2，需要升级到 4），并针对每个中间版本（2 到 3，然后 3 到 4）逐步运行每个版本的升级。</li>
<li>或者我们可以检查数据库：以 <code>db.objectStoreNames</code> 的形式获取现有对象库的列表。该对象是一个 <a href="https://html.spec.whatwg.org/multipage/common-dom-interfaces.html#domstringlist">DOMStringList</a> 提供 <code>contains(name)</code> 方法来检查 name 是否存在，再根据存在和不存在的内容进行更新。</li>
</ol>
<p>对于小型数据库，第二种方法可能更简单。</p>
<p>下面是第二种方法的演示:</p>
<div id="2wn2fhi0vs" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let openRequest = indexedDB.open(&quot;db&quot;, 2);

// 创建/升级 数据库而无需版本检查
openRequest.onupgradeneeded = function() {
  let db = openRequest.result;
  if (!db.objectStoreNames.contains('books')) { // 如果没有 “books” 数据
    db.createObjectStore('books', {keyPath: 'id'}); // 创造它
  }
};</code></pre>
        </div>
      </div>
      
      </div><p>删除对象库：</p>
<div id="autchbv77h" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>db.deleteObjectStore('books')</code></pre>
        </div>
      </div>
      
      </div><h2><a class="main__anchor" name="shi-wu" href="#shi-wu">事务</a></h2><p>术语“事务”是通用的，许多数据库中都有用到。</p>
<p>事务是一组操作，要么全部成功，要么全部失败。</p>
<p>例如，当一个人买东西时，我们需要：</p>
<ol>
<li>从他们的账户中扣除这笔钱。</li>
<li>将该项目添加到他们的清单中。</li>
</ol>
<p>如果完成了第一个操作，但是出了问题，比如停电。这时无法完成第二个操作，这非常糟糕。两件时应该要么都成功（购买完成，好！）或同时失败（这个人保留了钱，可以重新尝试）。</p>
<p>事务可以保证同时完成。</p>
<p><strong>所有数据操作都必须在 IndexedDB 中的事务内进行。</strong></p>
<p>启动事务：</p>
<div id="hg7gapelv5" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>db.transaction(store[, type]);</code></pre>
        </div>
      </div>
      
      </div><ul>
<li><code>store</code> 是事务要访问的库名称，例如 <code>&quot;books&quot;</code>。如果我们要访问多个库，则是库名称的数组。</li>
<li><code>type</code> – 事务类型，以下类型之一：
<ul>
<li><code>readonly</code> —— 只读，默认值。</li>
<li><code>readwrite</code> —— 只能读取和写入数据，而不能 创建/删除/更改 对象库。</li>
</ul>
</li>
</ul>
<p>还有 <code>versionchange</code> 事务类型：这种事务可以做任何事情，但不能被手动创建。IndexedDB 在打开数据库时，会自动为 <code>updateneeded</code> 处理程序创建 <code>versionchange</code> 事务。这就是它为什么可以更新数据库结构、创建/删除 对象库的原因。</p>
<div class="important important_smart">
            <div class="important__header"><span class="important__type">为什么会有不同类型的事务？</span></div>
            <div class="important__content"><p>性能是事务需要标记为 <code>readonly</code> 和 <code>readwrite</code> 的原因。</p>
<p>许多 <code>readonly</code> 事务能够同时访问同一存储区，但 <code>readwrite</code> 事务不能。因为 <code>readwrite</code> 事务会“锁定”存储区进行写操作。下一个事务必须等待前一个事务完成，才能访问相同的存储区。</p>
</div></div>
<p>创建事务后，我们可以将项目添加到库，就像这样：</p>
<div id="4ouceybicn" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:11,&quot;end&quot;:11},{&quot;start&quot;:3,&quot;end&quot;:3}]">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let transaction = db.transaction(&quot;books&quot;, &quot;readwrite&quot;); // (1)

// 获取对象库进行操作
let books = transaction.objectStore(&quot;books&quot;); // (2)

let book = {
  id: 'js',
  price: 10,
  created: new Date()
};

let request = books.add(book); // (3)

request.onsuccess = function() { // (4)
  console.log(&quot;Book added to the store&quot;, request.result);
};

request.onerror = function() {
  console.log(&quot;Error&quot;, request.error);
};</code></pre>
        </div>
      </div>
      
      </div><p>基本有四个步骤：</p>
<ol>
<li>创建一个事务，在（1）表明要访问的所有存储。</li>
<li>使用 <code>transaction.objectStore(name)</code>，在（2）中获取存储对象。</li>
<li>在（3）执行对对象库 <code>books.add(book)</code> 的请求。</li>
<li>……处理请求 成功/错误（4），还可以根据需要发出其他请求。</li>
</ol>
<p>对象库支持两种存储值的方法：</p>
<ul>
<li>
<p><strong>put(value, [key])</strong>
将 <code>value</code> 添加到存储区。仅当对象库没有 <code>keyPath</code> 或 <code>autoIncrement</code> 时，才提供 <code>key</code>。如果已经存在具有相同键的值，则将替换该值。</p>
</li>
<li>
<p><strong>add(value, [key])</strong>
与 <code>put</code> 相同，但是如果已经有一个值具有相同的键，则请求失败，并生成一个名为 <code>&quot;ConstraInterror&quot;</code> 的错误。</p>
</li>
</ul>
<p>与打开数据库类似，我们可以发送一个请求：<code>books.add(book)</code>，然后等待 <code>success/error</code> 事件。</p>
<ul>
<li><code>add</code> 的 <code>request.result</code> 是新对象的键。</li>
<li>错误在 <code>request.error</code>（如果有的话）中。</li>
</ul>
<h2><a class="main__anchor" name="shi-wu-de-zi-dong-ti-jiao" href="#shi-wu-de-zi-dong-ti-jiao">事务的自动提交</a></h2><p>在上面的示例中，我们启动了事务并发出了 <code>add</code> 请求。但正如前面提到的，一个事务可能有多个相关的请求，这些请求必须全部成功或全部失败。那么我们如何将事务标记为已完成，并不再请求呢？</p>
<p>简短的回答是：没有。</p>
<p>在下一个版本 3.0 规范中，可能会有一种手动方式来完成事务，但目前在 2.0 中还没有。</p>
<p><strong>当所有事务的请求完成，并且 <a href="../microtask-queue/index.html">微任务队列</a> 为空时，它将自动提交。</strong></p>
<p>通常，我们可以假设事务在其所有请求完成时提交，并且当前代码完成。</p>
<p>因此，在上面的示例中，不需要任何特殊调用即可完成事务。</p>
<p>事务自动提交原则有一个重要的副作用。不能在事务中间插入 <code>fetch</code>, <code>setTimeout</code> 等异步操作。IndexedDB 不会让事务等待这些操作完成。</p>
<p>在下面的代码中，<code>request2</code> 中的行 <code>(*)</code> 失败，因为事务已经提交，不能在其中发出任何请求:</p>
<div id="hyqslak0ys" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:4,&quot;end&quot;:4}]">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let request1 = books.add(book);

request1.onsuccess = function() {
  fetch('/').then(response =&gt; {
    let request2 = books.add(anotherBook); // (*)
    request2.onerror = function() {
      console.log(request2.error.name); // TransactionInactiveError
    };
  });
};</code></pre>
        </div>
      </div>
      
      </div><p>这是因为 <code>fetch</code> 是一个异步操作，一个宏任务。事务在浏览器开始执行宏任务之前关闭。</p>
<p>IndexedDB 规范的作者认为事务应该是短期的。主要是性能原因。</p>
<p>值得注意的是，<code>readwrite</code> 事务将存储“锁定”以进行写入。因此，如果应用程序的一部分启动了 <code>books</code> 对象库上的 <code>readwrite</code> 操作，那么希望执行相同操作的另一部分必须等待新事务“挂起”，直到第一个事务完成。如果事务处理需要很长时间，将会导致奇怪的延迟。</p>
<p>那么，该怎么办？</p>
<p>在上面的示例中，我们可以在新请求 <code>(*)</code> 之前创建一个新的 <code>db.transaction</code>。</p>
<p>如果需要在一个事务中把所有操作保持一致，更好的做法是将 IndexedDB 事务和“其他”异步内容分开。</p>
<p>首先，执行 <code>fetch</code>，并根据需要准备数据。然后创建事务并执行所有数据库请求，然后就正常了。</p>
<p>为了检测到成功完成的时刻，我们可以监听 <code>transaction.oncomplete</code> 事件:</p>
<div id="22jw8kvw0t" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let transaction = db.transaction(&quot;books&quot;, &quot;readwrite&quot;);

// ……执行操作……

transaction.oncomplete = function() {
  console.log(&quot;Transaction is complete&quot;); // 事务执行完成
};</code></pre>
        </div>
      </div>
      
      </div><p>只有 <code>complete</code> 才能保证将事务作为一个整体保存。个别请求可能会成功，但最终的写入操作可能会出错（例如 I/O 错误或其他错误）。</p>
<p>要手动中止事务，请调用：</p>
<div id="3c786iry9e" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>transaction.abort();</code></pre>
        </div>
      </div>
      
      </div><p>取消请求里所做的所有修改，并触发 <code>transaction.onabort</code> 事件。</p>
<h2><a class="main__anchor" name="cuo-wu-chu-li" href="#cuo-wu-chu-li">错误处理</a></h2><p>写入请求可能会失败。</p>
<p>这是意料之中的事，不仅是我们可能会犯的粗心失误，还有与事务本身相关的其他原因。例如超过了存储配额。因此，必须做好请求失败的处理。</p>
<p><strong>失败的请求将自动中止事务，并取消所有的更改。</strong></p>
<p>在一些情况下，我们会想自己去处理失败事务（例如尝试另一个请求）并让它继续执行，而不是取消现有的更改。可以调用 <code>request.onerror</code> 处理程序，在其中调用 <code>event.preventDefault()</code> 防止事务中止。</p>
<p>在下面的示例中，添加了一本新书，键 (<code>id</code>) 与现有的书相同。<code>store.add</code> 方法生成一个 <code>&quot;ConstraInterror&quot;</code>。可以在不取消事务的情况下进行处理：</p>
<div id="ddnswusckb" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let transaction = db.transaction(&quot;books&quot;, &quot;readwrite&quot;);

let book = { id: 'js', price: 10 };

let request = transaction.objectStore(&quot;books&quot;).add(book);

request.onerror = function(event) {
  // 有相同 id 的对象存在时，发生 ConstraintError
  if (request.error.name == &quot;ConstraintError&quot;) {
    console.log(&quot;Book with such id already exists&quot;); // 处理错误
    event.preventDefault(); // 不要中止事务
    // 这个 book 用另一个键？
  } else {
    // 意外错误，无法处理
    // 事务将中止
  }
};

transaction.onabort = function() {
  console.log(&quot;Error&quot;, transaction.error);
};</code></pre>
        </div>
      </div>
      
      </div><h3><a class="main__anchor" name="shi-jian-wei-tuo" href="#shi-jian-wei-tuo">事件委托</a></h3><p>每个请求都需要调用 onerror/onsuccess ？并不，可以使用事件委托来代替。</p>
<p><strong>IndexedDB 事件冒泡：请求 → 事务 → 数据库。</strong></p>
<p>所有事件都是 DOM 事件，有捕获和冒泡，但通常只使用冒泡阶段。</p>
<p>因此，出于报告或其他原因，我们可以使用 <code>db.onerror</code> 处理程序捕获所有错误：</p>
<div id="uslxee4byy" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>db.onerror = function(event) {
  let request = event.target; // 导致错误的请求

  console.log(&quot;Error&quot;, request.error);
};</code></pre>
        </div>
      </div>
      
      </div><p>……但是错误被完全处理了呢？这种情况不应该被报告。</p>
<p>我们可以通过在 <code>request.onerror</code> 中使用 <code>event.stopPropagation()</code> 来停止冒泡，从而停止 <code>db.onerror</code> 事件。</p>
<div id="aa6k9kp1qr" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>request.onerror = function(event) {
  if (request.error.name == &quot;ConstraintError&quot;) {
    console.log(&quot;Book with such id already exists&quot;); // 处理错误
    event.preventDefault(); // 不要中止事务
    event.stopPropagation(); // 不要让错误冒泡, 停止它的传播
  } else {
    // 什么都不做
    // 事务将中止
    // 我们可以解决 transaction.onabort 中的错误
  }
};</code></pre>
        </div>
      </div>
      
      </div><h2><a class="main__anchor" name="tong-guo-jian-sou-suo" href="#tong-guo-jian-sou-suo">通过键搜索</a></h2><p>对象库有两种主要的搜索类型：</p>
<ol>
<li>通过一个键或一个键范围。即：通过在“books”中存储的 <code>book.id</code>。</li>
<li>另一个对象字段，例如 <code>book.price</code>。</li>
</ol>
<p>首先，让我们来处理键和键范围 <code>(1)</code>。</p>
<p>涉及到的搜索方法，包括支持精确键，也包括所谓的“范围查询” —— <a href="https://www.w3.org/TR/IndexedDB/#keyrange">IDBKeyRange</a> 对象指定一个“键范围”。</p>
<p>使用以下调用函数创建范围：</p>
<ul>
<li><code>IDBKeyRange.lowerBound(lower, [open])</code> 表示：<code>≥lower</code>（如果 <code>open</code> 是 true，表示 <code>&gt;lower</code>）</li>
<li><code>IDBKeyRange.upperBound(upper, [open])</code> 表示：<code>≤upper</code>（如果 <code>open</code> 是 true，表示  <code>&lt;upper</code>）</li>
<li><code>IDBKeyRange.bound(lower, upper, [lowerOpen], [upperOpen])</code> 表示: 在 <code>lower</code> 和 <code>upper</code> 之间。如果 open 为 true，则相应的键不包括在范围中。</li>
<li><code>IDBKeyRange.only(key)</code> —— 仅包含一个键的范围 <code>key</code>，很少使用。</li>
</ul>
<p>所有搜索方法都接受一个查询参数 <code>query</code>，该参数可以是精确键或者键范围：</p>
<ul>
<li><code>store.get(query)</code> —— 按键或范围搜索第一个值。</li>
<li><code>store.getAll([query], [count])</code> —— 搜索所有值。如果 <code>count</code> 给定，则按 <code>count</code> 进行限制。</li>
<li><code>store.getKey(query)</code> —— 搜索满足查询的第一个键，通常是一个范围。</li>
<li><code>store.getAllKeys([query], [count])</code> —— 搜索满足查询的所有键，通常是一个范围。如果 <code>count</code> 给定，则最多为 count。</li>
<li><code>store.count([query])</code> —— 获取满足查询的键的总数，通常是一个范围。</li>
</ul>
<p>例如，我们存储区里有很多书。因为 <code>id</code> 字段是键，因此所有方法都可以按 <code>id</code> 进行搜索。</p>
<p>请求示例：</p>
<div id="huauut4ln7" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>// 获取一本书
books.get('js')

// 获取 'css' &lt;= id &lt;= 'html' 的书
books.getAll(IDBKeyRange.bound('css', 'html'))

// 获取 id &lt; 'html' 的书
books.getAll(IDBKeyRange.upperBound('html', true))

// 获取所有书
books.getAll()

// 获取所有 id &gt; 'js' 的键
books.getAllKeys(IDBKeyRange.lowerBound('js', true))</code></pre>
        </div>
      </div>
      
      </div><div class="important important_smart">
            <div class="important__header"><span class="important__type">对象库始终是有序的</span></div>
            <div class="important__content"><p>对象库按键对值进行内部排序。</p>
<p>因此，请求的返回值，是按照键的顺序排列的。</p>
</div></div>
<h2><a class="main__anchor" name="tong-guo-dai-suo-yin-de-zi-duan-sou-suo" href="#tong-guo-dai-suo-yin-de-zi-duan-sou-suo">通过带索引的字段搜索</a></h2><p>要根据其他对象字段进行搜索，我们需要创建一个名为“索引（index）”的附加数据结构。</p>
<p>索引是存储的&quot;附加项&quot;，用于跟踪给定的对象字段。对于该字段的每个值，它存储有该值的对象的键列表。下面会有更详细的图片。</p>
<p>语法：</p>
<div id="4u67lydoof" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>objectStore.createIndex(name, keyPath, [options]);</code></pre>
        </div>
      </div>
      
      </div><ul>
<li><strong><code>name</code></strong> —— 索引名称。</li>
<li><strong><code>keyPath</code></strong> —— 索引应该跟踪的对象字段的路径（我们将根据该字段进行搜索）。</li>
<li><strong><code>option</code></strong> —— 具有以下属性的可选对象：
<ul>
<li><strong><code>unique</code></strong> —— 如果为true，则存储中只有一个对象在 <code>keyPath</code> 上具有给定值。如果我们尝试添加重复项，索引将生成错误。</li>
<li><strong><code>multiEntry</code></strong> —— 只有 <code>keypath</code> 上的值是数组时才使用。这时，默认情况下，索引将默认把整个数组视为键。但是如果 <code>multiEntry</code> 为 true，那么索引将为该数组中的每个值保留一个存储对象的列表。所以数组成员成为了索引键。</li>
</ul>
</li>
</ul>
<p>在我们的示例中，是按照 <code>id</code> 键存储图书的。</p>
<p>假设我们想通过 <code>price</code> 进行搜索。</p>
<p>首先，我们需要创建一个索引。它像对象库一样，必须在 <code>upgradeneeded</code> 中创建完成：</p>
<div id="3d6le8w3sq" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:3,&quot;end&quot;:3}]">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>openRequest.onupgradeneeded = function() {
  // 在 versionchange 事务中，我们必须在这里创建索引
  let books = db.createObjectStore('books', {keyPath: 'id'});
  let index = books.createIndex('price_idx', 'price');
};</code></pre>
        </div>
      </div>
      
      </div><ul>
<li>该索引将跟踪 <code>price</code> 字段。</li>
<li>价格不是唯一的，可能有多本书价格相同，所以我们不设置唯一 <code>unique</code> 选项。</li>
<li>价格不是一个数组，因此不适用多入口 <code>multiEntry</code> 标志。</li>
</ul>
<p>假设我们的库存里有4本书。下面的图片显示了该索引 <code>index</code> 的确切内容：</p>
<figure><div class="image" style="width:440px">
      <div class="image__ratio" style="padding-top:65.68181818181819%"></div>
      <object type="image/svg+xml" data="../article/indexeddb/indexeddb-index.svg" width="440" height="289" class="image__image" data-use-theme>
        <img src="../article/indexeddb/indexeddb-index.svg" alt width="440" height="289">
      </object>
      </div></figure><p>如上所述，每个 price 值的索引（第二个参数）保存具有该价格的键的列表。</p>
<p>索引自动保持最新，所以我们不必关心它。</p>
<p>现在，当我们想要搜索给定的价格时，只需将相同的搜索方法应用于索引：</p>
<div id="ghdx7y78l5" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:4,&quot;end&quot;:4}]">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let transaction = db.transaction(&quot;books&quot;); // 只读
let books = transaction.objectStore(&quot;books&quot;);
let priceIndex = books.index(&quot;price_idx&quot;);

let request = priceIndex.getAll(10);

request.onsuccess = function() {
  if (request.result !== undefined) {
    console.log(&quot;Books&quot;, request.result); // 价格为 10 的书的数组
  } else {
    console.log(&quot;No such books&quot;);
  }
};</code></pre>
        </div>
      </div>
      
      </div><p>我们还可以使用 <code>IDBKeyRange</code> 创建范围，并查找 便宜/贵 的书：</p>
<div id="twaz7hfhdx" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>// 查找价格 &lt;=5 的书籍
let request = priceIndex.getAll(IDBKeyRange.upperBound(5));</code></pre>
        </div>
      </div>
      
      </div><p>在我们的例子中，索引是按照被跟踪对象字段价格 <code>price</code> 进行内部排序的。所以当我们进行搜索时，搜索结果也会按照价格排序。</p>
<h2><a class="main__anchor" name="cong-cun-chu-zhong-shan-chu" href="#cong-cun-chu-zhong-shan-chu">从存储中删除</a></h2><p><code>delete</code> 方法查找要由查询删除的值，调用格式类似于 <code>getAll</code></p>
<ul>
<li><strong><code>delete(query)</code></strong> —— 通过查询删除匹配的值。</li>
</ul>
<p>例如：</p>
<div id="7uwy9gksvw" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>// 删除 id='js' 的书
books.delete('js');</code></pre>
        </div>
      </div>
      
      </div><p>如果要基于价格或其他对象字段删除书。首先需要在索引中找到键，然后调用 <code>delete</code>：</p>
<div id="s0mjyse70c" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>// 找到价格 = 5 的钥匙
let request = priceIndex.getKey(5);

request.onsuccess = function() {
  let id = request.result;
  let deleteRequest = books.delete(id);
};</code></pre>
        </div>
      </div>
      
      </div><p>删除所有内容：</p>
<div id="ziytb8n7qr" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>books.clear(); // 清除存储。</code></pre>
        </div>
      </div>
      
      </div><h2><a class="main__anchor" name="guang-biao-cursors" href="#guang-biao-cursors">光标（Cursors）</a></h2><p>像 <code>getAll/getAllKeys</code> 这样的方法，会返回一个 键/值 数组。</p>
<p>但是一个对象库可能很大，比可用的内存还大。这时，<code>getAll</code> 就无法将所有记录作为一个数组获取。</p>
<p>该怎么办呢？</p>
<p>光标提供了解决这一问题的方法。</p>
<p><strong>光标是一种特殊的对象，它在给定查询的情况下遍历对象库，一次返回一个键/值，从而节省内存。</strong></p>
<p>由于对象库是按键在内部排序的，因此光标按键顺序（默认为升序）遍历存储。</p>
<p>语法:</p>
<div id="9stef5ac05" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>// 类似于 getAll，但带有光标：
let request = store.openCursor(query, [direction]);

// 获取键，而不是值（例如 getAllKeys）：store.openKeyCursor</code></pre>
        </div>
      </div>
      
      </div><ul>
<li><strong><code>query</code></strong> 是一个键或键范围，与 <code>getAll</code> 相同。</li>
<li><strong><code>direction</code></strong> 是一个可选参数，使用顺序是：
<ul>
<li><code>&quot;next&quot;</code> —— 默认值，光标从有最小索引的记录向上移动。</li>
<li><code>&quot;prev&quot;</code> —— 相反的顺序：从有最大的索引的记录开始下降。</li>
<li><code>&quot;nextunique&quot;</code>，<code>&quot;prevunique&quot;</code> —— 同上，但是跳过键相同的记录 （仅适用于索引上的光标，例如，对于价格为 5 的书，仅返回第一本）。</li>
</ul>
</li>
</ul>
<p><strong>光标对象的主要区别在于 <code>request.onSuccess</code> 多次触发：每个结果触发一次。</strong></p>
<p>这有一个如何使用光标的例子：</p>
<div id="2mrhupigxo" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let transaction = db.transaction(&quot;books&quot;);
let books = transaction.objectStore(&quot;books&quot;);

let request = books.openCursor();

// 为光标找到的每本书调用
request.onsuccess = function() {
  let cursor = request.result;
  if (cursor) {
    let key = cursor.key; // 书的键（id字段）
    let value = cursor.value; // 书本对象
    console.log(key, value);
    cursor.continue();
  } else {
    console.log(&quot;No more books&quot;);
  }
};</code></pre>
        </div>
      </div>
      
      </div><p>主要的光标方法有：</p>
<ul>
<li><code>advance(count)</code> —— 将光标向前移动 <code>count</code> 次，跳过值。</li>
<li><code>continue([key])</code> —— 将光标移至匹配范围中的下一个值（如果给定键，紧接键之后）。</li>
</ul>
<p>无论是否有更多的值匹配光标 —— 调用 <code>onsuccess</code>。结果中，我们可以获得指向下一条记录的光标，或者 <code>undefined</code>。</p>
<p>在上面的示例中，光标是为对象库创建的。</p>
<p>也可以在索引上创建一个光标。索引是允许按对象字段进行搜索的。在索引上的光标与在对象存储上的光标完全相同 — 它们通过一次返回一个值来节省内存。</p>
<p>对于索引上的游标，<code>cursor.key</code> 是索引键（例如：价格），我们应该使用 <code>cursor.primaryKey</code> 属性作为对象的键：</p>
<div id="1aenb2waan" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let request = priceIdx.openCursor(IDBKeyRange.upperBound(5));

// 为每条记录调用
request.onsuccess = function() {
  let cursor = request.result;
  if (cursor) {
    let primaryKey = cursor.primaryKey; // 下一个对象存储键（id 字段）
    let value = cursor.value; // 下一个对象存储对象（book 对象）
    let key = cursor.key; // 下一个索引键（price）
    console.log(key, value);
    cursor.continue();
  } else {
    console.log(&quot;No more books&quot;); // 没有书了
  }
};</code></pre>
        </div>
      </div>
      
      </div><h2><a class="main__anchor" name="promise-bao-zhuang-qi" href="#promise-bao-zhuang-qi">Promise 包装器</a></h2><p>将 <code>onsuccess/onerror</code> 添加到每个请求是一项相当麻烦的任务。我们可以通过使用事件委托（例如，在整个事务上设置处理程序）来简化我们的工作，但是 <code>async/await</code> 要方便的多。</p>
<p>在本章，我们会进一步使用一个轻便的承诺包装器 <a href="https://github.com/jakearchibald/idb">https://github.com/jakearchibald/idb</a> 。它使用 <a href="../promisify/index.html">promisified</a> IndexedDB 方法创建全局 <code>idb</code> 对象。</p>
<p>然后，我们可以不使用 <code>onsuccess/onerror</code>，而是这样写：</p>
<div id="zun3qw1mba" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let db = await idb.openDB('store', 1, db =&gt; {
  if (db.oldVersion == 0) {
    // 执行初始化
    db.createObjectStore('books', {keyPath: 'id'});
  }
});

let transaction = db.transaction('books', 'readwrite');
let books = transaction.objectStore('books');

try {
  await books.add(...);
  await books.add(...);

  await transaction.complete;

  console.log('jsbook saved');
} catch(err) {
  console.log('error', err.message);
}</code></pre>
        </div>
      </div>
      
      </div><p>现在我们有了可爱的“简单异步代码”和「try…catch」捕获的东西。</p>
<h3><a class="main__anchor" name="cuo-wu-chu-li-2" href="#cuo-wu-chu-li-2">错误处理</a></h3><p>如果我们没有捕获到错误，那么程序将一直失败，直到外部最近的 <code>try..catch</code> 捕获到为止。</p>
<p>未捕获的错误将成为 <code>window</code> 对象上的“unhandled promise rejection”事件。</p>
<p>我们可以这样处理这种错误：</p>
<div id="8hv8gd30xd" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>window.addEventListener('unhandledrejection', event =&gt; {
  let request = event.target; // IndexedDB 本机请求对象
  let error = event.reason; //  未处理的错误对象，与 request.error 相同
  // ……报告错误……
});</code></pre>
        </div>
      </div>
      
      </div><h3><a class="main__anchor" name="fei-huo-yue-shi-wu-xian-jing" href="#fei-huo-yue-shi-wu-xian-jing">“非活跃事务”陷阱</a></h3><p>我们都知道，浏览器一旦执行完成当前的代码和 <strong>微任务</strong> 之后，事务就会自动提交。因此，如果我们在事务中间放置一个类似 <code>fetch</code> 的宏任务，事务只是会自动提交，而不会等待它执行完成。因此，下一个请求会失败。</p>
<p>对于 promise 包装器和 <code>async/await</code>，情况是相同的。</p>
<p>这是在事务中间进行 <code>fetch</code> 的示例：</p>
<div id="j8zrfch00l" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let transaction = db.transaction(&quot;inventory&quot;, &quot;readwrite&quot;);
let inventory = transaction.objectStore(&quot;inventory&quot;);

await inventory.add({ id: 'js', price: 10, created: new Date() });

await fetch(...); // (*)

await inventory.add({ id: 'js', price: 10, created: new Date() }); // 错误</code></pre>
        </div>
      </div>
      
      </div><p><code>fetch</code> <code>(*)</code> 后的下一个 <code>inventory.add</code> 失败，出现“非活动事务”错误，因为这时事务已经被提交并且关闭了。</p>
<p>解决方法与使用本机 IndexedDB 时相同：进行新事务，或者将事情分开。</p>
<ol>
<li>准备数据，先获取所有需要的信息。</li>
<li>然后保存在数据库中。</li>
</ol>
<h3><a class="main__anchor" name="huo-qu-ben-ji-dui-xiang" href="#huo-qu-ben-ji-dui-xiang">获取本机对象</a></h3><p>在内部，包装器执行本机 IndexedDB 请求，并添加 <code>onerror/onsuccess</code> 方法，并返回 rejects/resolves 结果的 promise。</p>
<p>在大多数情况下都可以运行， 示例在这 <a href="https://github.com/jakearchibald/idb">https://github.com/jakearchibald/idb</a>。</p>
<p>极少数情况下，我们需要原始的 <code>request</code> 对象。可以将 <code>promise</code> 的 <code>promise.request</code> 属性，当作原始对象进行访问：</p>
<div id="dp037avdap" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let promise = books.add(book); // 获取 promise 对象(不要 await 结果)

let request = promise.request; // 本地请求对象
let transaction = request.transaction; // 本地事务对象

// ……做些本地的 IndexedDB 的处理……

let result = await promise; // 如果仍然需要</code></pre>
        </div>
      </div>
      
      </div><h2><a class="main__anchor" name="zong-jie" href="#zong-jie">总结</a></h2><p>IndexedDB 可以被认为是“localStorage on steroids”。这是一个简单的键值对数据库，功能强大到足以支持离线应用，而且用起来比较简单。</p>
<p>最好的指南是官方文档。<a href="https://w3c.github.io/IndexedDB">目前的版本</a> 是2.0，但是 <a href="https://w3c.github.io/IndexedDB/">3.0</a> 版本中的一些方法（差别不大）也得到部分支持。</p>
<p>基本用法可以用几个短语来描述：</p>
<ol>
<li>获取一个 promise 包装器，比如 <a href="https://github.com/jakearchibald/idb">idb</a>。</li>
<li>打开一个数据库：<code>idb.openDb(name, version, onupgradeneeded)</code>
<ul>
<li>在 <code>onupgradeneeded</code> 处理程序中创建对象存储和索引，或者根据需要执行版本更新。</li>
</ul>
</li>
<li>对于请求：
<ul>
<li>创建事务 <code>db.transaction('books')</code>（如果需要的话，设置 readwrite）。</li>
<li>获取对象存储 <code>transaction.objectStore('books')</code>。</li>
</ul>
</li>
<li>按键搜索，可以直接调用对象库上的方法。
<ul>
<li>要按对象字段搜索，需要创建索引。</li>
</ul>
</li>
<li>如果内存中容纳不下数据，请使用光标。</li>
</ol>
<p>这里有一个小应用程序示例：</p>
<div class="code-tabs"><div class="code-tabs__tools"><div class="code-tabs__scroll-wrap"><button class="code-tabs__scroll-button code-tabs__scroll-button_left" title="&amp;larr;" data-code-tabs-left="data-code-tabs-left"></button></div><div class="code-tabs__switches-wrap"><div class="code-tabs__switches" data-code-tabs-switches="data-code-tabs-switches"><div class="code-tabs__switches-items"><div class="code-tabs__switch">结果</div><div class="code-tabs__switch code-tabs__switch_current">index.html</div></div></div></div><div class="code-tabs__scroll-wrap"><button class="code-tabs__scroll-button code-tabs__scroll-button_right" title="&amp;rarr;" data-code-tabs-right="data-code-tabs-right"></button></div><div class="code-tabs__buttons"><a class="code-tabs__button code-tabs__button_external" target="_blank" title="在新窗口中打开" href="../article/indexeddb/books/index.html"></a><a class="code-tabs__button code-tabs__button_edit" target="_blank" title="在沙箱中编辑" href="https://plnkr.co/edit/q43Zgtwr54BGYnYK?p=preview"></a></div></div><div class="code-tabs__content" data-code-tabs-content="data-code-tabs-content" style="height:200px"><div class="code-tabs__section"><iframe class="code-tabs__result" src="../article/indexeddb/books/index.html"></iframe></div><div class="code-tabs__section code-tabs__section_current"><pre class="language-markup line-numbers"><code>&lt;!doctype html&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/idb@3.0.2/build/idb.min.js&quot;&gt;&lt;/script&gt;

&lt;button onclick=&quot;addBook()&quot;&gt;Add a book&lt;/button&gt;
&lt;button onclick=&quot;clearBooks()&quot;&gt;Clear books&lt;/button&gt;

&lt;p&gt;Books list:&lt;/p&gt;

&lt;ul id=&quot;listElem&quot;&gt;&lt;/ul&gt;

&lt;script&gt;
let db;

init();

async function init() {
  db = await idb.openDb('booksDb', 1, db =&gt; {
    db.createObjectStore('books', {keyPath: 'name'});
  });

  list();
}

async function list() {
  let tx = db.transaction('books');
  let bookStore = tx.objectStore('books');

  let books = await bookStore.getAll();

  if (books.length) {
    listElem.innerHTML = books.map(book =&gt; `&lt;li&gt;
        name: ${book.name}, price: ${book.price}
      &lt;/li&gt;`).join('');
  } else {
    listElem.innerHTML = '&lt;li&gt;No books yet. Please add books.&lt;/li&gt;'
  }


}

async function clearBooks() {
  let tx = db.transaction('books', 'readwrite');
  await tx.objectStore('books').clear();
  await list();
}

async function addBook() {
  let name = prompt(&quot;Book name?&quot;);
  let price = +prompt(&quot;Book price?&quot;);

  let tx = db.transaction('books', 'readwrite');

  try {
    await tx.objectStore('books').add({name, price});
    await list();
  } catch(err) {
    if (err.name == 'ConstraintError') {
      alert(&quot;Such book exists already&quot;);
      await addBook();
    } else {
      throw err;
    }
  }
}

window.addEventListener('unhandledrejection', event =&gt; {
  alert(&quot;Error: &quot; + event.reason.message);
});

&lt;/script&gt;</code></pre></div></div></div></div></article></div><div class="page__nav-wrap"><a class="page__nav page__nav_prev" href="../localstorage/index.html" data-tooltip="LocalStorage，sessionStorage"><span class="page__nav-text"><span class="page__nav-text-shortcut"></span></span><span class="page__nav-text-alternate">上一节</span></a><a class="page__nav page__nav_next" href="../animation/index.html" data-tooltip="动画"><span class="page__nav-text"><span class="page__nav-text-shortcut"></span></span><span class="page__nav-text-alternate">下一节</span></a></div><div class="article-tablet-foot tablet-only"><div class="article-tablet-foot__layout"><div class="share-icons"><span class="share-icons__title">分享</span><a class="share share_tw" href="https://twitter.com/share?url=https%3A%2F%2Fzh.javascript.info%2Findexeddb" rel="nofollow"></a><a class="share share_fb" href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fzh.javascript.info%2Findexeddb" rel="nofollow"></a></div><div class="article-tablet-foot__map"><a class="map" href="../tutorial/map/index.html" data-action="tutorial-map"><span class="map__text">教程路线图</span></a></div></div></div><div class="comments formatted" id="comments"><div class="comments__header"><h2 class="comments__header-title"><a href="#comments" name="comments">评论</a></h2><div class="comments__read-before"><span class="comments__read-before-link">在评论之前先阅读本内容…</span><div class="comments__read-before-popup"><div class="comments__read-before-popup-i"><ul><li>如果你发现教程有错误，或者有其他需要修改和提升的地方 — 请 <a href="https://github.com/javascript-tutorial/zh.javascript.info/issues">提交一个 GitHub issue</a> 或 pull request，而不是在这评论。</li><li>如果你对教程的内容有不理解的地方 — 请详细说明。</li><li>使用 <code>&lt;code&gt;</code> 标签插入只有几个词的代码，插入多行代码可以使用 <code>&lt;pre&gt;</code> 标签，对于超过 10 行的代码，建议你使用沙箱（<a href="https://plnkr.co/edit/?p=preview">plnkr</a>，<a href="https://jsbin.com">JSBin</a>，<a href="http://codepen.io">codepen</a>…）</li></ul></div></div></div></div><div id="disqus_thread"></div><script>var disqus_config = function() { if (!this.page) this.page = {}; Object.assign(this.page, {"url":"https:\/\/zh.javascript.info\/indexeddb","identifier":"\/indexeddb"}); };</script><script>var disqus_shortname = "zh-javascript-info";</script><script>var disqus_enabled = true;</script></div></main></div><div class="sidebar page__sidebar sidebar sidebar_sticky-footer"><button class="sidebar__toggle" data-sidebar-toggle></button><a class="map" href="../tutorial/map/index.html" data-action="tutorial-map" data-tooltip="教程路线图"></a><div class="sidebar__inner"><div class="sidebar__content"><div class="sidebar__section"><h4 class="sidebar__section-title">章节</h4><nav class="sidebar__navigation"><ul class="sidebar__navigation-links"><li class="sidebar__navigation-link"><a class="sidebar__link" href="../data-storage/index.html">在浏览器中存储数据</a></li></ul></nav></div><div class="sidebar__section"><h4 class="sidebar__section-title">课程导航</h4><nav class="sidebar__navigation"><ul class="sidebar__navigation-links"><li class="sidebar__navigation-link"><a class="sidebar__link" href="#da-kai-shu-ju-ku">打开数据库</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="#dui-xiang-ku-objectstore">对象库（object store）</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="#shi-wu">事务</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="#shi-wu-de-zi-dong-ti-jiao">事务的自动提交</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="#cuo-wu-chu-li">错误处理</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="#tong-guo-jian-sou-suo">通过键搜索</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="#tong-guo-dai-suo-yin-de-zi-duan-sou-suo">通过带索引的字段搜索</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="#cong-cun-chu-zhong-shan-chu">从存储中删除</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="#guang-biao-cursors">光标（Cursors）</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="#promise-bao-zhuang-qi">Promise 包装器</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="#zong-jie">总结</a></li></ul></nav></div><div class="sidebar__section"><nav class="sidebar__navigation"><ul class="sidebar__navigation-links"><li class="sidebar__navigation-link"><a class="sidebar__link" href="#comments">评论</a></li></ul></nav></div><div class="sidebar__section"><div class="sidebar__section-title">分享</div><a class="share share_tw sidebar__share" href="https://twitter.com/share?url=https%3A%2F%2Fzh.javascript.info%2Findexeddb" rel="nofollow"></a><a class="share share_fb sidebar__share" href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p[url]=https%3A%2F%2Fzh.javascript.info%2Findexeddb" rel="nofollow"></a></div><div class="sidebar__section"><a class="sidebar__link" href="https://github.com/javascript-tutorial/zh.javascript.info/blob/master/6-data-storage/03-indexeddb" rel="nofollow">在 GitHub 上编辑</a></div></div></div></div></div></div><div class="page-footer"><ul class="page-footer__list"><li class="page-footer__item page-footer__item_copy">©&nbsp;2007—2022&nbsp; Ilya Kantor</li><li class="page-footer__item page-footer__item_about"><a class="page-footer__link" href="../about/index.html">关于本项目</a></li><li class="page-footer__item page-footer__item_contact"><a class="page-footer__link" href="../about/index.html#contact-us">联系我们</a></li></ul></div></body></html>