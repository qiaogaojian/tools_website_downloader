<!DOCTYPE html><html lang="zh" data-theme-enabled="1"><head><script>window.currentUser = null;</script><script>window.rateUsdToNative = 6.3589;</script><title itemprop="name">装饰器模式和转发，call/apply</title><link href="../pack/styles.e61986aaa5d558f47fd2.css" rel="stylesheet"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes, minimum-scale=1.0"><meta name="apple-mobile-web-app-capable" content="yes"><!-- chrome autotranslate is enabled only for "en" main version--><meta name="google" content="notranslate"><script>if (window.devicePixelRatio > 1) document.cookie = 'pixelRatio=' + window.devicePixelRatio + ';path=/;expires=Tue, 19 Jan 2038 03:14:07 GMT';</script><link href="//fonts.googleapis.com/css?family=Open+Sans:bold,italic,bolditalic" rel="stylesheet"><link rel="apple-touch-icon-precomposed" href="../img/favicon/apple-touch-icon-precomposed.png"><link rel="canonical" href="https://zh.javascript.info/call-apply-decorators"><meta name="msapplication-TileColor" content="#222A2C"><meta name="msapplication-TileImage" content="/img/favicon/tileicon.png"><link rel="icon" href="../img/favicon/favicon.png"><meta itemprop="image" content="https://zh.javascript.info/img/site_preview_en_512x512.png"><meta property="og:title" content="装饰器模式和转发，call/apply"><meta property="og:image" content="../img/site_preview_en_1200x630.png"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta property="fb:admins" content="100001562528165"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="装饰器模式和转发，call/apply"><meta name="twitter:site" content="@iliakan"><meta name="twitter:creator" content="@iliakan"><meta name="twitter:image" content="https://zh.javascript.info/img/site_preview_en_512x512.png"><link rel="prev" href="/settimeout-setinterval"><link rel="next" href="/bind"><script>window.GA_ID = "UA-2056213-15";</script><script>window.YANDEX_METRIKA_ID = 65598091;</script><script>window.GoogleAnalyticsObject="ga",window.ga=function(){window.ga.q.push(arguments)},window.ga.q=[],window.ga.l=Date.now(),ga("create",GA_ID,"auto"),window.GTM_ID&&ga("require",GTM_ID),window.currentUser?ga("set","&uid",currentUser.id):ga("set","anonymizeIp",!0),window.addEventListener("error",function(e){var r=(e.filename||e.errorUrl)+": "+(e.lineno||e.errorLine),n=e.stack||e.error&&e.error.stack;ga("send","exception",{exDescription:e.message+" "+r+" "+n,exFatal:!0})});</script><script src="https://www.google-analytics.com/analytics.js" async></script><script>ga('send', 'pageview');</script><script>window.metrika={reachGoal:function(){}},window.yandex_metrika_callbacks=[function(){try{window.metrika=new Ya.Metrika({id:YANDEX_METRIKA_ID,webvisor:!0,clickmap:!0,params:{user:window.currentUser&&window.currentUser.id}}),metrika.trackLinks({delay:150}),window.addEventListener("error",function(r){window.metrika.reachGoal("JSERROR",{src:(r.filename||r.errorUrl)+": "+(r.lineno||r.errorLine),stack:r.stack||r.error&&r.error.stack,message:r.message})})}catch(r){}}];</script><script src="//mc.yandex.ru/metrika/watch.js" async></script><script>window.RECAPTCHA_ID = "6LfmLAEVAAAAAJMykMnf7aY8nkyTRmYi2ynx51R1";</script><script src="../pack/init.f551d10c469632252be6.js"></script><script src="../pack/head.7c4dbce7f0d4e5d1865e.js" defer></script><meta property="og:title" content="装饰器模式和转发，call/apply"><meta property="og:type" content="article"><script src="../pack/tutorial.0085805d53a665cf3a7e.js" defer></script><script src="../pack/footer.b5edaae5b6e4efe79394.js" defer></script></head><body class="no-icons"><script>window.fontTest();</script><div class="page-wrapper page-wrapper_sidebar_on"><!--[if IE]><div style="color:red;text-align:center">很抱歉，我们不支持 Internet Explorer 等浏览器，请使用一个更新版本的浏览器。</div><![endif]--><div class="sitetoolbar sitetoolbar_tutorial"><script>window.langs = [{"code":"ar","name":"Arabic"},{"code":"az","name":"Azerbaijani"},{"code":"bg","name":"Bulgarian"},{"code":"bn","name":"Bengali"},{"code":"bs","name":"Bosnian"},{"code":"ca","name":"Catalan"},{"code":"cs","name":"Czech"},{"code":"da","name":"Danish"},{"code":"de","name":"German"},{"code":"el","name":"Greek"},{"code":"en","name":"English"},{"code":"es","name":"Spanish"},{"code":"fa","name":"Persian (Farsi)"},{"code":"fi","name":"Finnish"},{"code":"fr","name":"French"},{"code":"he","name":"Hebrew"},{"code":"hi","name":"Hindi"},{"code":"hr","name":"Croatian"},{"code":"hu","name":"Hungarian"},{"code":"hy","name":"Armenian"},{"code":"id","name":"Indonesian"},{"code":"it","name":"Italian"},{"code":"ja","name":"Japanese"},{"code":"ka","name":"Georgian"},{"code":"kk","name":"Kazakh"},{"code":"km","name":"Central Khmer"},{"code":"ko","name":"Korean"},{"code":"lt","name":"Lithuanian"},{"code":"me","name":"Montenegrin"},{"code":"ml","name":"Malayalam"},{"code":"my","name":"Burmese"},{"code":"nl","name":"Dutch"},{"code":"no","name":"Norvegian"},{"code":"pa","name":"Punjabi"},{"code":"pl","name":"Polish"},{"code":"pt","name":"Portuguese"},{"code":"ro","name":"Romanian"},{"code":"ru","name":"Russian"},{"code":"si","name":"Sinhala"},{"code":"sk","name":"Slovak"},{"code":"sl","name":"Slovenian"},{"code":"sq","name":"Albanian"},{"code":"sr","name":"Serbian"},{"code":"ta","name":"Tamil"},{"code":"te","name":"Telugu"},{"code":"test","name":"Test"},{"code":"th","name":"Thai"},{"code":"tk","name":"Turkmen"},{"code":"tr","name":"Turkish"},{"code":"uk","name":"Ukrainian"},{"code":"ur","name":"Urdu"},{"code":"uz","name":"Uzbek"},{"code":"v2","name":"v2"},{"code":"vi","name":"Vietnamese"},{"code":"zh-hant","name":"Chinese Traditional"},{"code":"zh","name":"Chinese"}];</script><script>window.lang = "zh";</script><script>{let t=navigator.languages||[];t=t.map(t=>t.toLowerCase());let o,i,n=[];for(let o of window.langs)for(let i of t)if(i===o.code||i.startsWith(o.code+"-")){n.push(o);break}if(!o&&"ru"!=lang&&"en"!=lang){n.find(t=>"en"==t.code)&&(o=`\n            According to your browser headers, you know English. Please help to <a href="https://github.com/javascript-tutorial/${lang}.javascript.info#readme">translate the tutorial</a>.\n            Thank you!\n          `,i="notify-translate-tutorial-local")}if(o){let t=`<div class="notification notification_top notification_info sitetoolbar__notification" style="display:none" id="${i}">\n          <div class="notification__content">${o}</div>\n          <button class="notification__close" title="Close"></button>\n        </div>`;document.write(t),showTopNotification()}}</script><div class="sitetoolbar__content"><div class="sitetoolbar__lang-switcher"><button class="sitetoolbar__dropdown-button" data-dropdown-toggler>ZH</button><div class="sitetoolbar__dropdown-wrap"><div class="sitetoolbar__dropdown-body"><div class="sitetoolbar__lang-switcher-body"><div class="supported-langs supported-langs_toolbar"><div class="supported-langs__container"><ul class="supported-langs__list" style="height:200px"><li class="supported-langs__item"><a class="supported-langs__link" href="https://ar.javascript.info/call-apply-decorators"><span class="supported-langs__brief">AR</span><span class="supported-langs__title">عربي</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://javascript.info/call-apply-decorators"><span class="supported-langs__brief">EN</span><span class="supported-langs__title">English</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://es.javascript.info/call-apply-decorators"><span class="supported-langs__brief">ES</span><span class="supported-langs__title">Español</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://fr.javascript.info/call-apply-decorators"><span class="supported-langs__brief">FR</span><span class="supported-langs__title">Français</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://id.javascript.info/call-apply-decorators"><span class="supported-langs__brief">ID</span><span class="supported-langs__title">Indonesia</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://it.javascript.info/call-apply-decorators"><span class="supported-langs__brief">IT</span><span class="supported-langs__title">Italiano</span></a></li></ul><ul class="supported-langs__list" style="height:200px"><li class="supported-langs__item"><a class="supported-langs__link" href="https://ja.javascript.info/call-apply-decorators"><span class="supported-langs__brief">JA</span><span class="supported-langs__title">日本語</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://ko.javascript.info/call-apply-decorators"><span class="supported-langs__brief">KO</span><span class="supported-langs__title">한국어</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://learn.javascript.ru/call-apply-decorators"><span class="supported-langs__brief">RU</span><span class="supported-langs__title">Русский</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://tr.javascript.info/call-apply-decorators"><span class="supported-langs__brief">TR</span><span class="supported-langs__title">Türkçe</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://uk.javascript.info/call-apply-decorators"><span class="supported-langs__brief">UK</span><span class="supported-langs__title">Українська</span></a></li><li class="supported-langs__item supported-langs__item_current"><a class="supported-langs__link" href="index.html"><span class="supported-langs__brief">ZH</span><span class="supported-langs__title">简体中文</span></a></li></ul></div><div class="supported-langs__text">我们希望将这个开源项目提供给全世界的人。请帮助我们将教程的内容 <a href="https://github.com/javascript-tutorial/translate" rel="noopener noreferrer" target="_blank">翻译为你所掌握的语言</a> 对应的版本。</div></div></div></div></div></div><div class="sitetoolbar__logo-wrap"><a class="sitetoolbar__link sitetoolbar__link_logo" href="../index.html"><img class="sitetoolbar__logo sitetoolbar__logo_normal" src="../img/sitetoolbar__logo_en.svg" width="200" alt role="presentation"><img class="sitetoolbar__logo sitetoolbar__logo_normal sitetoolbar__logo_dark" src="../img/sitetoolbar__logo_en-white.svg" width="200" alt role="presentation"><img class="sitetoolbar__logo sitetoolbar__logo_small" src="../img/sitetoolbar__logo_small_en.svg" width="70" alt role="presentation"><img class="sitetoolbar__logo sitetoolbar__logo_small sitetoolbar__logo_dark" src="../img/sitetoolbar__logo_small_en-white.svg" width="70" alt role="presentation"><script>Array.prototype.forEach.call(document.querySelectorAll("img.sitetoolbar__logo"),function(e){let t=document.createElement("object");t.type="image/svg+xml",t.className=e.className,t.style.cssText="left:0;top:0;position:absolute",t.onload=function(){t.onload=null,e.style.visibility="hidden"},t.data=e.src,e.parentNode.insertBefore(t,e)});</script></a></div><div class="sitetoolbar__nav-toggle-wrap"><button class="sitetoolbar__nav-toggle" type="button"></button></div><nav class="sitetoolbar__sections"><ul class="sitetoolbar__sections-list"></ul></nav><div class="sitetoolbar__book-wrap"><a class="buy-book-button" href="../ebook/index.html"><span class="buy-book-button__extra-text">购买</span>EPUB/PDF</a></div><div class="sitetoolbar__theme-switcher"><div class="theme-changer"><label class="theme-changer__label" for="theme-changer-input" data-tooltip="Change theme"><input class="theme-changer__input" type="checkbox" id="theme-changer-input" data-theme-changer="data-theme-changer"><span class="theme-changer__icon theme-changer__icon_light-theme"></span><span class="theme-changer__icon theme-changer__icon_dark-theme"></span></label></div></div><div class="sitetoolbar__search-wrap"><div class="sitetoolbar__search-content"><button class="sitetoolbar__search-toggle" type="button"></button><form class="sitetoolbar__search" method="GET" action="/search"><div class="sitetoolbar__search-input"><div class="text-input"><input class="text-input__control" name="query" placeholder="在 Javascript.info 网站中搜索" required="required" type="text"></div><button class="sitetoolbar__find" type="submit">搜索</button></div></form></div></div></div><div class="tablet-menu"><div class="tablet-menu__line"><div class="tablet-menu__content"><form class="tablet-menu-search" action="/search/"><input class="tablet-menu-search__input" type="search" name="query" placeholder="在教程中搜索" required="required"><button class="tablet-menu-search__button" type="submit" name="type" value="articles">搜索</button></form></div></div><div class="tablet-menu__line"><div class="tablet-menu__content"><a class="map" href="../tutorial/map/index.html" data-action="tutorial-map"><span class="map__text">教程路线图</span></a></div></div><div class="tablet-menu__line"><div class="tablet-menu__content"><div class="theme-changer theme-changer_tablet-menu theme-changer_has-label"><label class="theme-changer__label" for="theme-changer-input-tablet" data-tooltip="Change theme"><input class="theme-changer__input" type="checkbox" id="theme-changer-input-tablet" data-theme-changer="data-theme-changer"><span class="theme-changer__icon theme-changer__icon_light-theme"></span><span class="theme-changer__icon theme-changer__icon_dark-theme"></span><span class="theme-changer__label-text theme-changer__label-text_light-theme">Light theme</span><span class="theme-changer__label-text theme-changer__label-text_dark-theme">Dark theme</span></label></div></div></div><div class="tablet-menu__line"><div class="tablet-menu__content"><div class="share-icons"><span class="share-icons__title">分享</span><a class="share share_tw" href="https://twitter.com/share?url=https%3A%2F%2Fzh.javascript.info%2Fcall-apply-decorators" rel="nofollow"></a><a class="share share_fb" href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fzh.javascript.info%2Fcall-apply-decorators" rel="nofollow"></a></div></div></div><div class="tablet-menu__line"><div class="tablet-menu__content"><select class="tablet-menu__nav input-select input-select input-select_small" onchange="if(this.value) window.location.href=this.value"><option value="https://ar.javascript.info/call-apply-decorators">عربي</option><option value="https://javascript.info/call-apply-decorators">English</option><option value="https://es.javascript.info/call-apply-decorators">Español</option><option value="https://fr.javascript.info/call-apply-decorators">Français</option><option value="https://id.javascript.info/call-apply-decorators">Indonesia</option><option value="https://it.javascript.info/call-apply-decorators">Italiano</option><option value="https://ja.javascript.info/call-apply-decorators">日本語</option><option value="https://ko.javascript.info/call-apply-decorators">한국어</option><option value="https://learn.javascript.ru/call-apply-decorators">Русский</option><option value="https://tr.javascript.info/call-apply-decorators">Türkçe</option><option value="https://uk.javascript.info/call-apply-decorators">Українська</option><option value="https://zh.javascript.info/call-apply-decorators" selected>简体中文</option></select></div></div></div><progress class="tutorial-progress" data-sticky value="57" max="92" data-tooltip="第 57/92 节"></progress></div><div class="page page_sidebar_on page_inner_padding"><script>if(localStorage.noSidebar){document.querySelector(".page").classList.remove("page_sidebar_on");let e=document.querySelector(".page-wrapper");e&&e.classList.remove("page-wrapper_sidebar_on")}setTimeout(function(){document.querySelector(".page").classList.add("page_sidebar-animation-on")});</script><div class="page__inner"><main class="main main_width-limit"><header class="main__header"><div class="main__header-inner"><div class="main__header-group"><ol class="breadcrumbs"><li class="breadcrumbs__item breadcrumbs__item_home"><a class="breadcrumbs__link" href="../index.html"><span class="breadcrumbs__hidden-text">教程</span></a></li><li class="breadcrumbs__item" id="breadcrumb-1"><a class="breadcrumbs__link" href="../js/index.html"><span>JavaScript 编程语言</span></a></li><li class="breadcrumbs__item" id="breadcrumb-2"><a class="breadcrumbs__link" href="../advanced-functions/index.html"><span>函数进阶内容</span></a></li><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"教程","item":"https://zh.javascript.info/"},{"@type":"ListItem","position":2,"name":"JavaScript 编程语言","item":"https://zh.javascript.info/js"},{"@type":"ListItem","position":3,"name":"函数进阶内容","item":"https://zh.javascript.info/advanced-functions"}]}</script></ol><div class="updated-at" data-tooltip="最后修改在 13日 二月 2022"><div class="updated-at__content">13日 二月 2022</div></div></div><h1 class="main__header-title">装饰器模式和转发，call/apply</h1></div></header><div class="content"><article class="formatted" itemscope itemtype="http://schema.org/TechArticle"><meta itemprop="name" content="装饰器模式和转发，call/apply"><div itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="email" content="iliakan@gmail.com"><meta itemprop="name" content="Ilya Kantor"></div><div itemprop="articleBody"><p>JavaScript 在处理函数时提供了非凡的灵活性。它们可以被传递，用作对象，现在我们将看到如何在它们之间 <strong>转发（forward）</strong> 调用并 <strong>装饰（decorate）</strong> 它们。</p>
<h2><a class="main__anchor" name="tou-ming-huan-cun" href="#tou-ming-huan-cun">透明缓存</a></h2><p>假设我们有一个 CPU 重负载的函数 <code>slow(x)</code>，但它的结果是稳定的。换句话说，对于相同的 <code>x</code>，它总是返回相同的结果。</p>
<p>如果经常调用该函数，我们可能希望将结果缓存（记住）下来，以避免在重新计算上花费额外的时间。</p>
<p>但是我们不是将这个功能添加到 <code>slow()</code> 中，而是创建一个包装器（wrapper）函数，该函数增加了缓存功能。正如我们将要看到的，这样做有很多好处。</p>
<p>下面是代码和解释：</p>
<div id="prsfruajid" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="运行" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="在沙箱中打开" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function slow(x) {
  // 这里可能会有重负载的 CPU 密集型工作
  alert(`Called with ${x}`);
  return x;
}

function cachingDecorator(func) {
  let cache = new Map();

  return function(x) {
    if (cache.has(x)) {    // 如果缓存中有对应的结果
      return cache.get(x); // 从缓存中读取结果
    }

    let result = func(x);  // 否则就调用 func

    cache.set(x, result);  // 然后将结果缓存（记住）下来
    return result;
  };
}

slow = cachingDecorator(slow);

alert( slow(1) ); // slow(1) 被缓存下来了，并返回结果
alert( &quot;Again: &quot; + slow(1) ); // 返回缓存中的 slow(1) 的结果

alert( slow(2) ); // slow(2) 被缓存下来了，并返回结果
alert( &quot;Again: &quot; + slow(2) ); // 返回缓存中的 slow(2) 的结果</code></pre>
        </div>
      </div>
      
      </div><p>在上面的代码中，<code>cachingDecorator</code> 是一个 <strong>装饰器（decorator）</strong>：一个特殊的函数，它接受另一个函数并改变它的行为。</p>
<p>其思想是，我们可以为任何函数调用 <code>cachingDecorator</code>，它将返回缓存包装器。这很棒啊，因为我们有很多函数可以使用这样的特性，而我们需要做的就是将 <code>cachingDecorator</code> 应用于它们。</p>
<p>通过将缓存与主函数代码分开，我们还可以使主函数代码变得更简单。</p>
<p><code>cachingDecorator(func)</code> 的结果是一个“包装器”：<code>function(x)</code> 将 <code>func(x)</code> 的调用“包装”到缓存逻辑中：</p>
<figure><div class="image" style="width:458px">
      <div class="image__ratio" style="padding-top:56.76855895196506%"></div>
      <object type="image/svg+xml" data="../article/call-apply-decorators/decorator-makecaching-wrapper.svg" width="458" height="260" class="image__image" data-use-theme>
        <img src="../article/call-apply-decorators/decorator-makecaching-wrapper.svg" alt width="458" height="260">
      </object>
      </div></figure><p>从外部代码来看，包装的 <code>slow</code> 函数执行的仍然是与之前相同的操作。它只是在其行为上添加了缓存功能。</p>
<p>总而言之，使用分离的 <code>cachingDecorator</code> 而不是改变 <code>slow</code> 本身的代码有几个好处：</p>
<ul>
<li><code>cachingDecorator</code> 是可重用的。我们可以将它应用于另一个函数。</li>
<li>缓存逻辑是独立的，它没有增加 <code>slow</code> 本身的复杂性（如果有的话）。</li>
<li>如果需要，我们可以组合多个装饰器（其他装饰器将遵循同样的逻辑）。</li>
</ul>
<h2><a class="main__anchor" name="shi-yong-funccall-she-ding-shang-xia-wen" href="#shi-yong-funccall-she-ding-shang-xia-wen">使用 “func.call” 设定上下文</a></h2><p>上面提到的缓存装饰器不适用于对象方法。</p>
<p>例如，在下面的代码中，<code>worker.slow()</code> 在装饰后停止工作：</p>
<div id="987towq3jq" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:30,&quot;end&quot;:30},{&quot;start&quot;:20,&quot;end&quot;:20}]">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="运行" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="在沙箱中打开" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>// 我们将对 worker.slow 的结果进行缓存
let worker = {
  someMethod() {
    return 1;
  },

  slow(x) {
    // 可怕的 CPU 过载任务
    alert(&quot;Called with &quot; + x);
    return x * this.someMethod(); // (*)
  }
};

// 和之前例子中的代码相同
function cachingDecorator(func) {
  let cache = new Map();
  return function(x) {
    if (cache.has(x)) {
      return cache.get(x);
    }
    let result = func(x); // (**)
    cache.set(x, result);
    return result;
  };
}

alert( worker.slow(1) ); // 原始方法有效

worker.slow = cachingDecorator(worker.slow); // 现在对其进行缓存

alert( worker.slow(2) ); // 蛤！Error: Cannot read property 'someMethod' of undefined</code></pre>
        </div>
      </div>
      
      </div><p>错误发生在试图访问 <code>this.someMethod</code> 并失败了的 <code>(*)</code> 行中。你能看出来为什么吗？</p>
<p>原因是包装器将原始函数调用为 <code>(**)</code> 行中的 <code>func(x)</code>。并且，当这样调用时，函数将得到 <code>this = undefined</code>。</p>
<p>如果尝试运行下面这段代码，我们会观察到类似的问题：</p>
<div id="79no85ncpf" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let func = worker.slow;
func(2);</code></pre>
        </div>
      </div>
      
      </div><p>因此，包装器将调用传递给原始方法，但没有上下文 <code>this</code>。因此，发生了错误。</p>
<p>让我们来解决这个问题。</p>
<p>有一个特殊的内建函数方法 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Function/call">func.call(context, …args)</a>，它允许调用一个显式设置 <code>this</code> 的函数。</p>
<p>语法如下：</p>
<div id="otjdnuil7q" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>func.call(context, arg1, arg2, ...)</code></pre>
        </div>
      </div>
      
      </div><p>它运行 <code>func</code>，提供的第一个参数作为 <code>this</code>，后面的作为参数（arguments）。</p>
<p>简单地说，这两个调用几乎相同：</p>
<div id="fm5kwhkadb" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>func(1, 2, 3);
func.call(obj, 1, 2, 3)</code></pre>
        </div>
      </div>
      
      </div><p>它们调用的都是 <code>func</code>，参数是 <code>1</code>、<code>2</code> 和 <code>3</code>。唯一的区别是 <code>func.call</code> 还会将 <code>this</code> 设置为 <code>obj</code>。</p>
<p>例如，在下面的代码中，我们在不同对象的上下文中调用 <code>sayHi</code>：<code>sayHi.call(user)</code> 运行 <code>sayHi</code> 并提供了 <code>this=user</code>，然后下一行设置 <code>this=admin</code>：</p>
<div id="b4vqajdjcq" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="运行" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="在沙箱中打开" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function sayHi() {
  alert(this.name);
}

let user = { name: &quot;John&quot; };
let admin = { name: &quot;Admin&quot; };

// 使用 call 将不同的对象传递为 &quot;this&quot;
sayHi.call( user ); // John
sayHi.call( admin ); // Admin</code></pre>
        </div>
      </div>
      
      </div><p>在这里我们用带有给定上下文和 phrase 的 <code>call</code> 调用 <code>say</code>：</p>
<div id="iqmjuldh7x" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="运行" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="在沙箱中打开" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function say(phrase) {
  alert(this.name + ': ' + phrase);
}

let user = { name: &quot;John&quot; };

// user 成为 this，&quot;Hello&quot; 成为第一个参数
say.call( user, &quot;Hello&quot; ); // John: Hello</code></pre>
        </div>
      </div>
      
      </div><p>在我们的例子中，我们可以在包装器中使用 <code>call</code> 将上下文传递给原始函数：</p>
<div id="ep4zdtk0sv" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:17,&quot;end&quot;:17}]">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="运行" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="在沙箱中打开" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let worker = {
  someMethod() {
    return 1;
  },

  slow(x) {
    alert(&quot;Called with &quot; + x);
    return x * this.someMethod(); // (*)
  }
};

function cachingDecorator(func) {
  let cache = new Map();
  return function(x) {
    if (cache.has(x)) {
      return cache.get(x);
    }
    let result = func.call(this, x); // 现在 &quot;this&quot; 被正确地传递了
    cache.set(x, result);
    return result;
  };
}

worker.slow = cachingDecorator(worker.slow); // 现在对其进行缓存

alert( worker.slow(2) ); // 工作正常
alert( worker.slow(2) ); // 工作正常，没有调用原始函数（使用的缓存）</code></pre>
        </div>
      </div>
      
      </div><p>现在一切都正常工作了。</p>
<p>为了让大家理解地更清晰一些，让我们更深入地看看 <code>this</code> 是如何被传递的：</p>
<ol>
<li>在经过装饰之后，<code>worker.slow</code> 现在是包装器 <code>function (x) { ... }</code>。</li>
<li>因此，当 <code>worker.slow(2)</code> 执行时，包装器将 <code>2</code> 作为参数，并且 <code>this=worker</code>（它是点符号 <code>.</code> 之前的对象）。</li>
<li>在包装器内部，假设结果尚未缓存，<code>func.call(this, x)</code> 将当前的 <code>this</code>（<code>=worker</code>）和当前的参数（<code>=2</code>）传递给原始方法。</li>
</ol>
<h2><a class="main__anchor" name="chuan-di-duo-ge-can-shu" href="#chuan-di-duo-ge-can-shu">传递多个参数</a></h2><p>现在让我们把 <code>cachingDecorator</code> 写得更加通用。到现在为止，它只能用于单参数函数。</p>
<p>现在如何缓存多参数 <code>worker.slow</code> 方法呢？</p>
<div id="7nu1d7548h" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let worker = {
  slow(min, max) {
    return min + max; // scary CPU-hogger is assumed
  }
};

// 应该记住相同参数的调用
worker.slow = cachingDecorator(worker.slow);</code></pre>
        </div>
      </div>
      
      </div><p>之前，对于单个参数 <code>x</code>，我们可以只使用 <code>cache.set(x, result)</code> 来保存结果，并使用 <code>cache.get(x)</code> 来检索并获取结果。但是现在，我们需要记住 <strong>参数组合</strong> <code>(min,max)</code> 的结果。原生的 <code>Map</code> 仅将单个值作为键（key）。</p>
<p>这儿有许多解决方案可以实现：</p>
<ol>
<li>实现一个新的（或使用第三方的）类似 map 的更通用并且允许多个键的数据结构。</li>
<li>使用嵌套 map：<code>cache.set(min)</code> 将是一个存储（键值）对 <code>(max, result)</code> 的 <code>Map</code>。所以我们可以使用 <code>cache.get(min).get(max)</code> 来获取 <code>result</code>。</li>
<li>将两个值合并为一个。为了灵活性，我们可以允许为装饰器提供一个“哈希函数”，该函数知道如何将多个值合并为一个值。</li>
</ol>
<p>对于许多实际应用，第三种方式就足够了，所以我们就用这个吧。</p>
<p>当然，我们需要传入的不仅是 <code>x</code>，还需要传入 <code>func.call</code> 的所有参数。让我们回想一下，在 <code>function()</code> 中我们可以得到一个包含所有参数的伪数组（pseudo-array）<code>arguments</code>，那么 <code>func.call(this, x)</code> 应该被替换为 <code>func.call(this, ...arguments)</code>。</p>
<p>这是一个更强大的 <code>cachingDecorator</code>：</p>
<div id="k2s4h0edvh" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:15,&quot;end&quot;:15},{&quot;start&quot;:10,&quot;end&quot;:10}]">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="运行" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="在沙箱中打开" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let worker = {
  slow(min, max) {
    alert(`Called with ${min},${max}`);
    return min + max;
  }
};

function cachingDecorator(func, hash) {
  let cache = new Map();
  return function() {
    let key = hash(arguments); // (*)
    if (cache.has(key)) {
      return cache.get(key);
    }

    let result = func.call(this, ...arguments); // (**)

    cache.set(key, result);
    return result;
  };
}

function hash(args) {
  return args[0] + ',' + args[1];
}

worker.slow = cachingDecorator(worker.slow, hash);

alert( worker.slow(3, 5) ); // works
alert( &quot;Again &quot; + worker.slow(3, 5) ); // same (cached)</code></pre>
        </div>
      </div>
      
      </div><p>现在这个包装器可以处理任意数量的参数了（尽管哈希函数还需要被进行调整以允许任意数量的参数。一种有趣的处理方法将在下面讲到）。</p>
<p>这里有两个变化：</p>
<ul>
<li>在 <code>(*)</code> 行中它调用 <code>hash</code> 来从 <code>arguments</code> 创建一个单独的键。这里我们使用一个简单的“连接”函数，将参数 <code>(3, 5)</code> 转换为键 <code>&quot;3,5&quot;</code>。更复杂的情况可能需要其他哈希函数。</li>
<li>然后 <code>(**)</code> 行使用 <code>func.call(this, ...arguments)</code> 将包装器获得的上下文和所有参数（不仅仅是第一个参数）传递给原始函数。</li>
</ul>
<h2><a class="main__anchor" name="funcapply" href="#funcapply">func.apply</a></h2><p>我们可以使用 <code>func.apply(this, arguments)</code> 代替 <code>func.call(this, ...arguments)</code>。</p>
<p>内建方法 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">func.apply</a> 的语法是：</p>
<div id="a5lvlus2ra" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>func.apply(context, args)</code></pre>
        </div>
      </div>
      
      </div><p>它运行 <code>func</code> 设置 <code>this=context</code>，并使用类数组对象 <code>args</code> 作为参数列表（arguments）。</p>
<p><code>call</code> 和 <code>apply</code> 之间唯一的语法区别是，<code>call</code> 期望一个参数列表，而 <code>apply</code> 期望一个包含这些参数的类数组对象。</p>
<p>因此，这两个调用几乎是等效的：</p>
<div id="1mairnbg5c" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>func.call(context, ...args);
func.apply(context, args);</code></pre>
        </div>
      </div>
      
      </div><p>它们使用给定的上下文和参数执行相同的 <code>func</code> 调用。</p>
<p>只有一个关于 <code>args</code> 的细微的差别：</p>
<ul>
<li>Spread 语法 <code>...</code> 允许将 <strong>可迭代对象</strong> <code>args</code> 作为列表传递给 <code>call</code>。</li>
<li><code>apply</code> 只接受 <strong>类数组</strong> <code>args</code>。</li>
</ul>
<p>……对于即可迭代又是类数组的对象，例如一个真正的数组，我们使用 <code>call</code> 或 <code>apply</code> 均可，但是 <code>apply</code> 可能会更快，因为大多数 JavaScript 引擎在内部对其进行了优化。</p>
<p>将所有参数连同上下文一起传递给另一个函数被称为“呼叫转移（call forwarding）”。</p>
<p>这是它的最简形式：</p>
<div id="xfwcibmtca" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let wrapper = function() {
  return func.apply(this, arguments);
};</code></pre>
        </div>
      </div>
      
      </div><p>当外部代码调用这种包装器 <code>wrapper</code> 时，它与原始函数 <code>func</code> 的调用是无法区分的。</p>
<h2><a class="main__anchor" name="method-borrowing" href="#method-borrowing">借用一种方法</a></h2><p>现在，让我们对哈希函数再做一个较小的改进：</p>
<div id="mmbare1q9y" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function hash(args) {
  return args[0] + ',' + args[1];
}</code></pre>
        </div>
      </div>
      
      </div><p>截至目前，它仅适用于两个参数。如果它可以适用于任何数量的 <code>args</code> 就更好了。</p>
<p>自然的解决方案是使用 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/join">arr.join</a> 方法：</p>
<div id="42hmzqe4uf" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function hash(args) {
  return args.join();
}</code></pre>
        </div>
      </div>
      
      </div><p>……不幸的是，这不行。因为我们正在调用 <code>hash(arguments)</code>，<code>arguments</code> 对象既是可迭代对象又是类数组对象，但它并不是真正的数组。</p>
<p>所以在它上面调用 <code>join</code> 会失败，我们可以在下面看到：</p>
<div id="jp6kvbrm4d" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:1,&quot;end&quot;:1}]">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="运行" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="在沙箱中打开" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function hash() {
  alert( arguments.join() ); // Error: arguments.join is not a function
}

hash(1, 2);</code></pre>
        </div>
      </div>
      
      </div><p>不过，有一种简单的方法可以使用数组的 join 方法：</p>
<div id="k0se0rayxu" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:1,&quot;end&quot;:1}]">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="运行" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="在沙箱中打开" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function hash() {
  alert( [].join.call(arguments) ); // 1,2
}

hash(1, 2);</code></pre>
        </div>
      </div>
      
      </div><p>这个技巧被称为 <strong>方法借用（method borrowing）</strong>。</p>
<p>我们从常规数组 <code>[].join</code> 中获取（借用）join 方法，并使用 <code>[].join.call</code> 在 <code>arguments</code> 的上下文中运行它。</p>
<p>它为什么有效？</p>
<p>那是因为原生方法 <code>arr.join(glue)</code> 的内部算法非常简单。</p>
<p>从规范中几乎“按原样”解释如下：</p>
<ol>
<li>让 <code>glue</code> 成为第一个参数，如果没有参数，则使用逗号 <code>&quot;,&quot;</code>。</li>
<li>让 <code>result</code> 为空字符串。</li>
<li>将 <code>this[0]</code> 附加到 <code>result</code>。</li>
<li>附加 <code>glue</code> 和 <code>this[1]</code>。</li>
<li>附加 <code>glue</code> 和 <code>this[2]</code>。</li>
<li>……以此类推，直到 <code>this.length</code> 项目被粘在一起。</li>
<li>返回 <code>result</code>。</li>
</ol>
<p>因此，从技术上讲，它需要 <code>this</code> 并将 <code>this[0]</code>，<code>this[1]</code> ……等 join 在一起。它的编写方式是故意允许任何类数组的 <code>this</code> 的（不是巧合，很多方法都遵循这种做法）。这就是为什么它也可以和 <code>this=arguments</code> 一起使用。</p>
<h2><a class="main__anchor" name="zhuang-shi-qi-he-han-shu-shu-xing" href="#zhuang-shi-qi-he-han-shu-shu-xing">装饰器和函数属性</a></h2><p>通常，用装饰的函数替换一个函数或一个方法是安全的，除了一件小东西。如果原始函数有属性，例如 <code>func.calledCount</code> 或其他，则装饰后的函数将不再提供这些属性。因为这是装饰器。因此，如果有人使用它们，那么就需要小心。</p>
<p>例如，在上面的示例中，如果 <code>slow</code> 函数具有任何属性，而 <code>cachingDecorator(slow)</code> 则是一个没有这些属性的包装器。</p>
<p>一些包装器可能会提供自己的属性。例如，装饰器会计算一个函数被调用了多少次以及花费了多少时间，并通过包装器属性公开（expose）这些信息。</p>
<p>存在一种创建装饰器的方法，该装饰器可保留对函数属性的访问权限，但这需要使用特殊的 <code>Proxy</code> 对象来包装函数。我们将在后面的 <a href="../proxy/index.html#proxy-apply">Proxy 和 Reflect</a> 中学习它。</p>
<h2><a class="main__anchor" name="zong-jie" href="#zong-jie">总结</a></h2><p><strong>装饰器</strong> 是一个围绕改变函数行为的包装器。主要工作仍由该函数来完成。</p>
<p>装饰器可以被看作是可以添加到函数的 “features” 或 “aspects”。我们可以添加一个或添加多个。而这一切都无需更改其代码！</p>
<p>为了实现 <code>cachingDecorator</code>，我们研究了以下方法：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Function/call">func.call(context, arg1, arg2…)</a> —— 用给定的上下文和参数调用 <code>func</code>。</li>
<li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">func.apply(context, args)</a> —— 调用 <code>func</code> 将 <code>context</code> 作为 <code>this</code> 和类数组的 <code>args</code> 传递给参数列表。</li>
</ul>
<p>通用的 <strong>呼叫转移（call forwarding）</strong> 通常是使用 <code>apply</code> 完成的：</p>
<div id="31ssikruht" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let wrapper = function() {
  return original.apply(this, arguments);
};</code></pre>
        </div>
      </div>
      
      </div><p>我们也可以看到一个 <strong>方法借用（method borrowing）</strong> 的例子，就是我们从一个对象中获取一个方法，并在另一个对象的上下文中“调用”它。采用数组方法并将它们应用于参数 <code>arguments</code> 是很常见的。另一种方法是使用 Rest 参数对象，该对象是一个真正的数组。</p>
<p>在 JavaScript 领域里有很多装饰器（decorators）。通过解决本章的任务，来检查你掌握它们的程度吧。</p>
</div></article><div class="tasks formatted"><h2 class="tasks__title" id="tasks"><a class="tasks__title-anchor main__anchor main__anchor main__anchor_noicon" href="#tasks">任务</a></h2><div class="task tasks__task"><div class="task__header"><div class="task__title-wrap"><h3 class="task__title"><a class="main__anchor" href="#jian-die-zhuang-shi-qi" name="jian-die-zhuang-shi-qi">间谍装饰器</a></h3><a class="task__open-link" href="../task/spy-decorator/index.html" target="_blank"></a></div><div class="task__header-note"><span class="task__importance" title="任务的重要程度有多高，等级从 1 到 5。">重要程度: 5</span></div><div class="task__content"><div class="task__formatted"><p>创建一个装饰器 <code>spy(func)</code>，它应该返回一个包装器，该包装器将所有对函数的调用保存在其 <code>calls</code> 属性中。</p>
<p>每个调用都保存为一个参数数组。</p>
<p>例如：</p>
<div id="yci1il5gd5" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:4,&quot;end&quot;:4}]">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function work(a, b) {
  alert( a + b ); // work 是一个任意的函数或方法
}

work = spy(work);

work(1, 2); // 3
work(4, 5); // 9

for (let args of work.calls) {
  alert( 'call:' + args.join() ); // &quot;call:1,2&quot;, &quot;call:4,5&quot;
}</code></pre>
        </div>
      </div>
      
      </div><p>P.S. 该装饰器有时对于单元测试很有用。它的高级形式是 <a href="http://sinonjs.org/">Sinon.JS</a> 库中的 <code>sinon.spy</code>。</p>
<p><a href="https://plnkr.co/edit/x2fWpIcijyAoXA2r?p=preview" target="_blank" data-plunk-id="x2fWpIcijyAoXA2r">打开带有测试的沙箱。</a></p></div><button class="task__solution" type="button">解决方案</button><div class="task__answer"><div class="task__answer-content"><div class="formatted"><p>由 <code>spy(f)</code> 返回的包装器应存储所有参数，然后使用 <code>f.apply</code> 转发调用。</p>
<div id="tfku1yjswk" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function spy(func) {

  function wrapper(...args) {
    // using ...args instead of arguments to store &quot;real&quot; array in wrapper.calls
    wrapper.calls.push(args);
    return func.apply(this, args);
  }

  wrapper.calls = [];

  return wrapper;
}</code></pre>
        </div>
      </div>
      
      </div><p><a href="https://plnkr.co/edit/7enYdetrfcpQP6Wr?p=preview" target="_blank" data-plunk-id="7enYdetrfcpQP6Wr">使用沙箱的测试功能打开解决方案。</a></p></div></div><button class="close-button task__answer-close" type="button" title="关闭"></button></div></div></div></div><div class="task tasks__task"><div class="task__header"><div class="task__title-wrap"><h3 class="task__title"><a class="main__anchor" href="#yan-shi-zhuang-shi-qi" name="yan-shi-zhuang-shi-qi">延时装饰器</a></h3><a class="task__open-link" href="/task/delay" target="_blank"></a></div><div class="task__header-note"><span class="task__importance" title="任务的重要程度有多高，等级从 1 到 5。">重要程度: 5</span></div><div class="task__content"><div class="task__formatted"><p>创建一个装饰器 <code>delay(f, ms)</code>，该装饰器将 <code>f</code> 的每次调用延时 <code>ms</code> 毫秒。</p>
<p>例如：</p>
<div id="4qy42z3kkp" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function f(x) {
  alert(x);
}

// create wrappers
let f1000 = delay(f, 1000);
let f1500 = delay(f, 1500);

f1000(&quot;test&quot;); // 在 1000ms 后显示 &quot;test&quot;
f1500(&quot;test&quot;); // 在 1500ms 后显示 &quot;test&quot;</code></pre>
        </div>
      </div>
      
      </div><p>换句话说，<code>delay(f, ms)</code> 返回的是延迟 <code>ms</code> 后的 <code>f</code> 的变体。</p>
<p>在上面的代码中，<code>f</code> 是单个参数的函数，但是你的解决方案应该传递所有参数和上下文 <code>this</code>。</p>
<p><a href="https://plnkr.co/edit/U5OHN5aRZVeXmKLS?p=preview" target="_blank" data-plunk-id="U5OHN5aRZVeXmKLS">打开带有测试的沙箱。</a></p></div><button class="task__solution" type="button">解决方案</button><div class="task__answer"><div class="task__answer-content"><div class="formatted"><p>解决方案：</p>
<div id="792mkiz1mx" data-trusted="1" class="code-example" data-demo="1">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="运行" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="在沙箱中打开" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function delay(f, ms) {

  return function() {
    setTimeout(() =&gt; f.apply(this, arguments), ms);
  };

}

let f1000 = delay(alert, 1000);

f1000(&quot;test&quot;); // shows &quot;test&quot; after 1000ms</code></pre>
        </div>
      </div>
      
      </div><p>注意这里是如何使用箭头函数的。我们知道，箭头函数没有自己的 <code>this</code> 和 <code>arguments</code>，所以 <code>f.apply(this, arguments)</code> 从包装器中获取 <code>this</code> 和 <code>arguments</code>。</p>
<p>如果我们传递一个常规函数，<code>setTimeout</code> 将调用它且不带参数和 <code>this=window</code>（假设我们在浏览器环境）。</p>
<p>我们仍然可以通过使用中间变量来传递正确的 <code>this</code>，但这有点麻烦：</p>
<div id="8kdlsuhlwy" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function delay(f, ms) {

  return function(...args) {
    let savedThis = this; // 将 this 存储到中间变量
    setTimeout(function() {
      f.apply(savedThis, args); // 在这儿使用它
    }, ms);
  };

}</code></pre>
        </div>
      </div>
      
      </div><p><a href="https://plnkr.co/edit/MrjiLHcgwBBlxPhA?p=preview" target="_blank" data-plunk-id="MrjiLHcgwBBlxPhA">使用沙箱的测试功能打开解决方案。</a></p></div></div><button class="close-button task__answer-close" type="button" title="关闭"></button></div></div></div></div><div class="task tasks__task"><div class="task__header"><div class="task__title-wrap"><h3 class="task__title"><a class="main__anchor" href="#fang-dou-zhuang-shi-qi" name="fang-dou-zhuang-shi-qi">防抖装饰器</a></h3><a class="task__open-link" href="../task/debounce/index.html" target="_blank"></a></div><div class="task__header-note"><span class="task__importance" title="任务的重要程度有多高，等级从 1 到 5。">重要程度: 5</span></div><div class="task__content"><div class="task__formatted"><p><code>debounce(f, ms)</code> 装饰器的结果是一个包装器，该包装器将暂停对 <code>f</code> 的调用，直到经过 <code>ms</code> 毫秒的非活动状态（没有函数调用，“冷却期”），然后使用最新的参数调用 <code>f</code> 一次。</p>
<p>换句话说，<code>debounce</code> 就像一个“接听电话”的秘书，并一直等到 <code>ms</code> 毫秒的安静时间之后，才将最新的呼叫信息传达给“老板”（调用实际的 <code>f</code>）。</p>
<p>举个例子，我们有一个函数 <code>f</code>，并将其替换为 <code>f = debounce(f, 1000)</code>。</p>
<p>然后，如果包装函数分别在 0ms、200ms 和 500ms 时被调用了，之后没有其他调用，那么实际的 <code>f</code> 只会在 1500ms 时被调用一次。也就是说：从最后一次调用开始经过 1000ms 的冷却期之后。</p>
<figure><div class="image" style="width:500px">
      <div class="image__ratio" style="padding-top:36.6%"></div>
      <object type="image/svg+xml" data="../task/debounce/debounce.svg" width="500" height="183" class="image__image" data-use-theme>
        <img src="../task/debounce/debounce.svg" alt width="500" height="183">
      </object>
      </div></figure><p>……并且，它将获得最后一个调用的所有参数，其他调用的参数将被忽略。</p>
<p>以下是其实现代码（使用了 <a href="https://lodash.com/docs/4.17.15#debounce">Lodash library</a> 中的防抖装饰器 ):</p>
<div id="rrnddg1ega" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let f = _.debounce(alert, 1000);

f(&quot;a&quot;);
setTimeout( () =&gt; f(&quot;b&quot;), 200);
setTimeout( () =&gt; f(&quot;c&quot;), 500);
// 防抖函数从最后一次函数调用以后等待 1000ms，然后执行：alert(&quot;c&quot;)</code></pre>
        </div>
      </div>
      
      </div><p>现在我们举一个实际中的例子。假设用户输入了一些内容，我们想要在用户输入完成时向服务器发送一个请求。</p>
<p>我们没有必要为每一个字符的输入都发送请求。相反，我们想要等一段时间，然后处理整个结果。</p>
<p>在 Web 浏览器中，我们可以设置一个事件处理程序 —— 一个在每次输入内容发生改动时都会调用的函数。通常，监听所有按键输入的事件的处理程序会被调用的非常频繁。但如果我们为这个处理程序做一个 1000ms 的 <code>debounce</code> 处理，它仅会在最后一次输入后的 1000ms 后被调用一次。</p>
<p>在这个实时演示的示例中，处理程序将结果显示在了下面的方框中，试试看：</p>
<div class="code-result">
    <div class="code-result__toolbar toolbar"></div>
    <iframe class="code-result__iframe" data-trusted="1" style="height:200px" src="https://zh.js.cx/task/debounce/debounce/"></iframe>
  </div><p>看到了吗？第二个输入框调用了防抖函数，所以它的内容是在最后一次输入的 1000ms 后被处理的。</p>
<p>因此，<code>debounce</code> 是一个处理一系列事件的好方法：无论是系列键盘输入，鼠标移动还是其他类似的事件。</p>
<p>它在最后一次调用之后等待给定的时间，然后运行其可以处理结果的函数。</p>
<p>任务是实现一个 <code>debounce</code> 装饰器。</p>
<p>提示：如果你好好想想，实现它只需要几行代码 :)</p>
<p><a href="https://plnkr.co/edit/jpPCNl1yLYpjv3zh?p=preview" target="_blank" data-plunk-id="jpPCNl1yLYpjv3zh">打开带有测试的沙箱。</a></p></div><button class="task__solution" type="button">解决方案</button><div class="task__answer"><div class="task__answer-content"><div class="formatted"><div id="qkzv4eb59f" data-trusted="1" class="code-example" data-demo="1">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function debounce(func, ms) {
  let timeout;
  return function() {
    clearTimeout(timeout);
    timeout = setTimeout(() =&gt; func.apply(this, arguments), ms);
  };
}</code></pre>
        </div>
      </div>
      
      </div><p>调用 <code>debounce</code> 会返回一个包装器。当它被调用时，它会安排一个在给定的 <code>ms</code> 之后对原始函数的调用，并取消之前的此类超时。</p>
<p><a href="https://plnkr.co/edit/gMKXi5iAe2ZtZAI9?p=preview" target="_blank" data-plunk-id="gMKXi5iAe2ZtZAI9">使用沙箱的测试功能打开解决方案。</a></p></div></div><button class="close-button task__answer-close" type="button" title="关闭"></button></div></div></div></div><div class="task tasks__task"><div class="task__header"><div class="task__title-wrap"><h3 class="task__title"><a class="main__anchor" href="#jie-liu-zhuang-shi-qi" name="jie-liu-zhuang-shi-qi">节流装饰器</a></h3><a class="task__open-link" href="../task/throttle/index.html" target="_blank"></a></div><div class="task__header-note"><span class="task__importance" title="任务的重要程度有多高，等级从 1 到 5。">重要程度: 5</span></div><div class="task__content"><div class="task__formatted"><p>创建一个“节流”装饰器 <code>throttle(f, ms)</code> —— 返回一个包装器。</p>
<p>当被多次调用时，它会在每 <code>ms</code> 毫秒最多将调用传递给 <code>f</code> 一次。</p>
<p>与去抖的不同是，它是个完全不同的装饰器：</p>
<ul>
<li><code>debounce</code> 会在“冷却（cooldown）”期后运行函数一次。适用于处理最终结果。</li>
<li><code>throttle</code> 运行函数的频率不会大于所给定的时间 <code>ms</code> 毫秒。适用于不应该经常进行的定期更新。</li>
</ul>
<p>换句话说，<code>throttle</code> 就像接电话的秘书，但是打扰老板（实际调用 <code>f</code>）的频率不能超过每 <code>ms</code> 毫秒一次。</p>
<p>让我们看看现实生活中的应用程序，以便更好地理解这个需求，并了解它的来源。</p>
<p><strong>例如，我们想要跟踪鼠标移动。</strong></p>
<p>在浏览器中，我们可以设置一个函数，使其在每次鼠标移动时运行，并获取鼠标移动时的指针位置。在使用鼠标的过程中，此函数通常会执行地非常频繁，大概每秒 100 次（每 10 毫秒）。</p>
<p><strong>我们想要在鼠标指针移动时，更新网页上的某些信息。</strong></p>
<p>……但是更新函数 <code>update()</code> 太重了，无法在每个微小移动上都执行。高于每 100ms 更新一次的更新频次也没有意义。</p>
<p>因此，我们将其包装到装饰器中：使用 <code>throttle(update, 100)</code> 作为在每次鼠标移动时运行的函数，而不是原始的 <code>update()</code>。装饰器会被频繁地调用，但是最多每 100ms 将调用转发给 <code>update()</code> 一次。</p>
<p>在视觉上，它看起来像这样：</p>
<ol>
<li>对于第一个鼠标移动，装饰的变体立即将调用传递给 <code>update</code>。这很重要，用户会立即看到我们对其动作的反应。</li>
<li>然后，随着鼠标移动，直到 <code>100ms</code> 没有任何反应。装饰的变体忽略了调用。</li>
<li>在 <code>100ms</code> 结束时 —— 最后一个坐标又发生了一次 <code>update</code>。</li>
<li>然后，最后，鼠标停在某处。装饰的变体会等到 <code>100ms</code> 到期，然后用最后一个坐标运行一次 <code>update</code>。因此，非常重要的是，处理最终的鼠标坐标。</li>
</ol>
<p>一个代码示例：</p>
<div id="st5ckjknbc" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function f(a) {
  console.log(a);
}

// f1000 最多每 1000ms 将调用传递给 f 一次
let f1000 = throttle(f, 1000);

f1000(1); // 显示 1
f1000(2); // (节流，尚未到 1000ms)
f1000(3); // (节流，尚未到 1000ms)

// 当 1000ms 时间到...
// ...输出 3，中间值 2 被忽略</code></pre>
        </div>
      </div>
      
      </div><p>P.S. 参数（arguments）和传递给 <code>f1000</code> 的上下文 <code>this</code> 应该被传递给原始的 <code>f</code>。</p>
<p><a href="https://plnkr.co/edit/3rhoX0FThZ4d5CRm?p=preview" target="_blank" data-plunk-id="3rhoX0FThZ4d5CRm">打开带有测试的沙箱。</a></p></div><button class="task__solution" type="button">解决方案</button><div class="task__answer"><div class="task__answer-content"><div class="formatted"><div id="stkbs9z7mf" data-trusted="1" class="code-example" data-demo="1">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function throttle(func, ms) {

  let isThrottled = false,
    savedArgs,
    savedThis;

  function wrapper() {

    if (isThrottled) { // (2)
      savedArgs = arguments;
      savedThis = this;
      return;
    }
    isThrottled = true;

    func.apply(this, arguments); // (1)

    setTimeout(function() {
      isThrottled = false; // (3)
      if (savedArgs) {
        wrapper.apply(savedThis, savedArgs);
        savedArgs = savedThis = null;
      }
    }, ms);
  }

  return wrapper;
}</code></pre>
        </div>
      </div>
      
      </div><p>调用 <code>throttle(func, ms)</code> 返回 <code>wrapper</code>。</p>
<ol>
<li>在第一次调用期间，<code>wrapper</code> 只运行 <code>func</code> 并设置冷却状态（<code>isThrottled = true</code>）。</li>
<li>在这种状态下，所有调用都记忆在 <code>savedArgs/savedThis</code> 中。请注意，上下文和参数（arguments）同等重要，应该被记下来。我们同时需要他们以重现调用。</li>
<li>……然后经过 <code>ms</code> 毫秒后，触发 <code>setTimeout</code>。冷却状态被移除（<code>isThrottled = false</code>），如果我们忽略了调用，则将使用最后记忆的参数和上下文执行 <code>wrapper</code>。</li>
</ol>
<p>第 3 步运行的不是 <code>func</code>，而是 <code>wrapper</code>，因为我们不仅需要执行 <code>func</code>，还需要再次进入冷却状态并设置 timeout 以重置它。</p>
<p><a href="https://plnkr.co/edit/qPkjbY2vhQdXFkN7?p=preview" target="_blank" data-plunk-id="qPkjbY2vhQdXFkN7">使用沙箱的测试功能打开解决方案。</a></p></div></div><button class="close-button task__answer-close" type="button" title="关闭"></button></div></div></div></div></div></div><div class="page__nav-wrap"><a class="page__nav page__nav_prev" href="../settimeout-setinterval/index.html" data-tooltip="调度：setTimeout 和 setInterval"><span class="page__nav-text"><span class="page__nav-text-shortcut"></span></span><span class="page__nav-text-alternate">上一节</span></a><a class="page__nav page__nav_next" href="../bind/index.html" data-tooltip="函数绑定"><span class="page__nav-text"><span class="page__nav-text-shortcut"></span></span><span class="page__nav-text-alternate">下一节</span></a></div><div class="article-tablet-foot tablet-only"><div class="article-tablet-foot__layout"><div class="share-icons"><span class="share-icons__title">分享</span><a class="share share_tw" href="https://twitter.com/share?url=https%3A%2F%2Fzh.javascript.info%2Fcall-apply-decorators" rel="nofollow"></a><a class="share share_fb" href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fzh.javascript.info%2Fcall-apply-decorators" rel="nofollow"></a></div><div class="article-tablet-foot__map"><a class="map" href="../tutorial/map/index.html" data-action="tutorial-map"><span class="map__text">教程路线图</span></a></div></div></div><div class="comments formatted" id="comments"><div class="comments__header"><h2 class="comments__header-title"><a href="#comments" name="comments">评论</a></h2><div class="comments__read-before"><span class="comments__read-before-link">在评论之前先阅读本内容…</span><div class="comments__read-before-popup"><div class="comments__read-before-popup-i"><ul><li>如果你发现教程有错误，或者有其他需要修改和提升的地方 — 请 <a href="https://github.com/javascript-tutorial/zh.javascript.info/issues">提交一个 GitHub issue</a> 或 pull request，而不是在这评论。</li><li>如果你对教程的内容有不理解的地方 — 请详细说明。</li><li>使用 <code>&lt;code&gt;</code> 标签插入只有几个词的代码，插入多行代码可以使用 <code>&lt;pre&gt;</code> 标签，对于超过 10 行的代码，建议你使用沙箱（<a href="https://plnkr.co/edit/?p=preview">plnkr</a>，<a href="https://jsbin.com">JSBin</a>，<a href="http://codepen.io">codepen</a>…）</li></ul></div></div></div></div><div id="disqus_thread"></div><script>var disqus_config = function() { if (!this.page) this.page = {}; Object.assign(this.page, {"url":"https:\/\/zh.javascript.info\/call-apply-decorators","identifier":"\/call-apply-decorators"}); };</script><script>var disqus_shortname = "zh-javascript-info";</script><script>var disqus_enabled = true;</script></div></main></div><div class="sidebar page__sidebar sidebar sidebar_sticky-footer"><button class="sidebar__toggle" data-sidebar-toggle></button><a class="map" href="../tutorial/map/index.html" data-action="tutorial-map" data-tooltip="教程路线图"></a><div class="sidebar__inner"><div class="sidebar__content"><div class="sidebar__section"><h4 class="sidebar__section-title">章节</h4><nav class="sidebar__navigation"><ul class="sidebar__navigation-links"><li class="sidebar__navigation-link"><a class="sidebar__link" href="../advanced-functions/index.html">函数进阶内容</a></li></ul></nav></div><div class="sidebar__section"><h4 class="sidebar__section-title">课程导航</h4><nav class="sidebar__navigation"><ul class="sidebar__navigation-links"><li class="sidebar__navigation-link"><a class="sidebar__link" href="#tou-ming-huan-cun">透明缓存</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="#shi-yong-funccall-she-ding-shang-xia-wen">使用 “func.call” 设定上下文</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="#chuan-di-duo-ge-can-shu">传递多个参数</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="#funcapply">func.apply</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="#method-borrowing">借用一种方法</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="#zhuang-shi-qi-he-han-shu-shu-xing">装饰器和函数属性</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="#zong-jie">总结</a></li></ul></nav></div><div class="sidebar__section"><nav class="sidebar__navigation"><ul class="sidebar__navigation-links"><li class="sidebar__navigation-link"><a class="sidebar__link" href="#tasks">任务 (4)</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="#comments">评论</a></li></ul></nav></div><div class="sidebar__section"><div class="sidebar__section-title">分享</div><a class="share share_tw sidebar__share" href="https://twitter.com/share?url=https%3A%2F%2Fzh.javascript.info%2Fcall-apply-decorators" rel="nofollow"></a><a class="share share_fb sidebar__share" href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p[url]=https%3A%2F%2Fzh.javascript.info%2Fcall-apply-decorators" rel="nofollow"></a></div><div class="sidebar__section"><a class="sidebar__link" href="https://github.com/javascript-tutorial/zh.javascript.info/blob/master/1-js/06-advanced-functions/09-call-apply-decorators" rel="nofollow">在 GitHub 上编辑</a></div></div></div></div></div></div><div class="page-footer"><ul class="page-footer__list"><li class="page-footer__item page-footer__item_copy">©&nbsp;2007—2022&nbsp; Ilya Kantor</li><li class="page-footer__item page-footer__item_about"><a class="page-footer__link" href="../about/index.html">关于本项目</a></li><li class="page-footer__item page-footer__item_contact"><a class="page-footer__link" href="../about/index.html#contact-us">联系我们</a></li></ul></div></body></html>