<!DOCTYPE html><html lang="zh" data-theme-enabled="1"><head><script>window.currentUser = null;</script><script>window.rateUsdToNative = 6.3589;</script><title itemprop="name">类继承</title><link href="../pack/styles.e61986aaa5d558f47fd2.css" rel="stylesheet"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes, minimum-scale=1.0"><meta name="apple-mobile-web-app-capable" content="yes"><!-- chrome autotranslate is enabled only for "en" main version--><meta name="google" content="notranslate"><script>if (window.devicePixelRatio > 1) document.cookie = 'pixelRatio=' + window.devicePixelRatio + ';path=/;expires=Tue, 19 Jan 2038 03:14:07 GMT';</script><link href="//fonts.googleapis.com/css?family=Open+Sans:bold,italic,bolditalic" rel="stylesheet"><link rel="apple-touch-icon-precomposed" href="../img/favicon/apple-touch-icon-precomposed.png"><link rel="canonical" href="https://zh.javascript.info/class-inheritance"><meta name="msapplication-TileColor" content="#222A2C"><meta name="msapplication-TileImage" content="/img/favicon/tileicon.png"><link rel="icon" href="../img/favicon/favicon.png"><meta itemprop="image" content="https://zh.javascript.info/img/site_preview_en_512x512.png"><meta property="og:title" content="类继承"><meta property="og:image" content="../img/site_preview_en_1200x630.png"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta property="fb:admins" content="100001562528165"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="类继承"><meta name="twitter:site" content="@iliakan"><meta name="twitter:creator" content="@iliakan"><meta name="twitter:image" content="https://zh.javascript.info/img/site_preview_en_512x512.png"><link rel="prev" href="/class"><link rel="next" href="/static-properties-methods"><script>window.GA_ID = "UA-2056213-15";</script><script>window.YANDEX_METRIKA_ID = 65598091;</script><script>window.GoogleAnalyticsObject="ga",window.ga=function(){window.ga.q.push(arguments)},window.ga.q=[],window.ga.l=Date.now(),ga("create",GA_ID,"auto"),window.GTM_ID&&ga("require",GTM_ID),window.currentUser?ga("set","&uid",currentUser.id):ga("set","anonymizeIp",!0),window.addEventListener("error",function(e){var r=(e.filename||e.errorUrl)+": "+(e.lineno||e.errorLine),n=e.stack||e.error&&e.error.stack;ga("send","exception",{exDescription:e.message+" "+r+" "+n,exFatal:!0})});</script><script src="https://www.google-analytics.com/analytics.js" async></script><script>ga('send', 'pageview');</script><script>window.metrika={reachGoal:function(){}},window.yandex_metrika_callbacks=[function(){try{window.metrika=new Ya.Metrika({id:YANDEX_METRIKA_ID,webvisor:!0,clickmap:!0,params:{user:window.currentUser&&window.currentUser.id}}),metrika.trackLinks({delay:150}),window.addEventListener("error",function(r){window.metrika.reachGoal("JSERROR",{src:(r.filename||r.errorUrl)+": "+(r.lineno||r.errorLine),stack:r.stack||r.error&&r.error.stack,message:r.message})})}catch(r){}}];</script><script src="//mc.yandex.ru/metrika/watch.js" async></script><script>window.RECAPTCHA_ID = "6LfmLAEVAAAAAJMykMnf7aY8nkyTRmYi2ynx51R1";</script><script src="../pack/init.f551d10c469632252be6.js"></script><script src="../pack/head.7c4dbce7f0d4e5d1865e.js" defer></script><meta property="og:title" content="类继承"><meta property="og:type" content="article"><script src="../pack/tutorial.0085805d53a665cf3a7e.js" defer></script><script src="../pack/footer.b5edaae5b6e4efe79394.js" defer></script></head><body class="no-icons"><script>window.fontTest();</script><div class="page-wrapper page-wrapper_sidebar_on"><!--[if IE]><div style="color:red;text-align:center">很抱歉，我们不支持 Internet Explorer 等浏览器，请使用一个更新版本的浏览器。</div><![endif]--><div class="sitetoolbar sitetoolbar_tutorial"><script>window.langs = [{"code":"ar","name":"Arabic"},{"code":"az","name":"Azerbaijani"},{"code":"bg","name":"Bulgarian"},{"code":"bn","name":"Bengali"},{"code":"bs","name":"Bosnian"},{"code":"ca","name":"Catalan"},{"code":"cs","name":"Czech"},{"code":"da","name":"Danish"},{"code":"de","name":"German"},{"code":"el","name":"Greek"},{"code":"en","name":"English"},{"code":"es","name":"Spanish"},{"code":"fa","name":"Persian (Farsi)"},{"code":"fi","name":"Finnish"},{"code":"fr","name":"French"},{"code":"he","name":"Hebrew"},{"code":"hi","name":"Hindi"},{"code":"hr","name":"Croatian"},{"code":"hu","name":"Hungarian"},{"code":"hy","name":"Armenian"},{"code":"id","name":"Indonesian"},{"code":"it","name":"Italian"},{"code":"ja","name":"Japanese"},{"code":"ka","name":"Georgian"},{"code":"kk","name":"Kazakh"},{"code":"km","name":"Central Khmer"},{"code":"ko","name":"Korean"},{"code":"lt","name":"Lithuanian"},{"code":"me","name":"Montenegrin"},{"code":"ml","name":"Malayalam"},{"code":"my","name":"Burmese"},{"code":"nl","name":"Dutch"},{"code":"no","name":"Norvegian"},{"code":"pa","name":"Punjabi"},{"code":"pl","name":"Polish"},{"code":"pt","name":"Portuguese"},{"code":"ro","name":"Romanian"},{"code":"ru","name":"Russian"},{"code":"si","name":"Sinhala"},{"code":"sk","name":"Slovak"},{"code":"sl","name":"Slovenian"},{"code":"sq","name":"Albanian"},{"code":"sr","name":"Serbian"},{"code":"ta","name":"Tamil"},{"code":"te","name":"Telugu"},{"code":"test","name":"Test"},{"code":"th","name":"Thai"},{"code":"tk","name":"Turkmen"},{"code":"tr","name":"Turkish"},{"code":"uk","name":"Ukrainian"},{"code":"ur","name":"Urdu"},{"code":"uz","name":"Uzbek"},{"code":"v2","name":"v2"},{"code":"vi","name":"Vietnamese"},{"code":"zh-hant","name":"Chinese Traditional"},{"code":"zh","name":"Chinese"}];</script><script>window.lang = "zh";</script><script>{let t=navigator.languages||[];t=t.map(t=>t.toLowerCase());let o,i,n=[];for(let o of window.langs)for(let i of t)if(i===o.code||i.startsWith(o.code+"-")){n.push(o);break}if(!o&&"ru"!=lang&&"en"!=lang){n.find(t=>"en"==t.code)&&(o=`\n            According to your browser headers, you know English. Please help to <a href="https://github.com/javascript-tutorial/${lang}.javascript.info#readme">translate the tutorial</a>.\n            Thank you!\n          `,i="notify-translate-tutorial-local")}if(o){let t=`<div class="notification notification_top notification_info sitetoolbar__notification" style="display:none" id="${i}">\n          <div class="notification__content">${o}</div>\n          <button class="notification__close" title="Close"></button>\n        </div>`;document.write(t),showTopNotification()}}</script><div class="sitetoolbar__content"><div class="sitetoolbar__lang-switcher"><button class="sitetoolbar__dropdown-button" data-dropdown-toggler>ZH</button><div class="sitetoolbar__dropdown-wrap"><div class="sitetoolbar__dropdown-body"><div class="sitetoolbar__lang-switcher-body"><div class="supported-langs supported-langs_toolbar"><div class="supported-langs__container"><ul class="supported-langs__list" style="height:200px"><li class="supported-langs__item"><a class="supported-langs__link" href="https://ar.javascript.info/class-inheritance"><span class="supported-langs__brief">AR</span><span class="supported-langs__title">عربي</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://javascript.info/class-inheritance"><span class="supported-langs__brief">EN</span><span class="supported-langs__title">English</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://es.javascript.info/class-inheritance"><span class="supported-langs__brief">ES</span><span class="supported-langs__title">Español</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://fr.javascript.info/class-inheritance"><span class="supported-langs__brief">FR</span><span class="supported-langs__title">Français</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://id.javascript.info/class-inheritance"><span class="supported-langs__brief">ID</span><span class="supported-langs__title">Indonesia</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://it.javascript.info/class-inheritance"><span class="supported-langs__brief">IT</span><span class="supported-langs__title">Italiano</span></a></li></ul><ul class="supported-langs__list" style="height:200px"><li class="supported-langs__item"><a class="supported-langs__link" href="https://ja.javascript.info/class-inheritance"><span class="supported-langs__brief">JA</span><span class="supported-langs__title">日本語</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://ko.javascript.info/class-inheritance"><span class="supported-langs__brief">KO</span><span class="supported-langs__title">한국어</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://learn.javascript.ru/class-inheritance"><span class="supported-langs__brief">RU</span><span class="supported-langs__title">Русский</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://tr.javascript.info/class-inheritance"><span class="supported-langs__brief">TR</span><span class="supported-langs__title">Türkçe</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://uk.javascript.info/class-inheritance"><span class="supported-langs__brief">UK</span><span class="supported-langs__title">Українська</span></a></li><li class="supported-langs__item supported-langs__item_current"><a class="supported-langs__link" href="index.html"><span class="supported-langs__brief">ZH</span><span class="supported-langs__title">简体中文</span></a></li></ul></div><div class="supported-langs__text">我们希望将这个开源项目提供给全世界的人。请帮助我们将教程的内容 <a href="https://github.com/javascript-tutorial/translate" rel="noopener noreferrer" target="_blank">翻译为你所掌握的语言</a> 对应的版本。</div></div></div></div></div></div><div class="sitetoolbar__logo-wrap"><a class="sitetoolbar__link sitetoolbar__link_logo" href="../index.html"><img class="sitetoolbar__logo sitetoolbar__logo_normal" src="../img/sitetoolbar__logo_en.svg" width="200" alt role="presentation"><img class="sitetoolbar__logo sitetoolbar__logo_normal sitetoolbar__logo_dark" src="../img/sitetoolbar__logo_en-white.svg" width="200" alt role="presentation"><img class="sitetoolbar__logo sitetoolbar__logo_small" src="../img/sitetoolbar__logo_small_en.svg" width="70" alt role="presentation"><img class="sitetoolbar__logo sitetoolbar__logo_small sitetoolbar__logo_dark" src="../img/sitetoolbar__logo_small_en-white.svg" width="70" alt role="presentation"><script>Array.prototype.forEach.call(document.querySelectorAll("img.sitetoolbar__logo"),function(e){let t=document.createElement("object");t.type="image/svg+xml",t.className=e.className,t.style.cssText="left:0;top:0;position:absolute",t.onload=function(){t.onload=null,e.style.visibility="hidden"},t.data=e.src,e.parentNode.insertBefore(t,e)});</script></a></div><div class="sitetoolbar__nav-toggle-wrap"><button class="sitetoolbar__nav-toggle" type="button"></button></div><nav class="sitetoolbar__sections"><ul class="sitetoolbar__sections-list"></ul></nav><div class="sitetoolbar__book-wrap"><a class="buy-book-button" href="../ebook/index.html"><span class="buy-book-button__extra-text">购买</span>EPUB/PDF</a></div><div class="sitetoolbar__theme-switcher"><div class="theme-changer"><label class="theme-changer__label" for="theme-changer-input" data-tooltip="Change theme"><input class="theme-changer__input" type="checkbox" id="theme-changer-input" data-theme-changer="data-theme-changer"><span class="theme-changer__icon theme-changer__icon_light-theme"></span><span class="theme-changer__icon theme-changer__icon_dark-theme"></span></label></div></div><div class="sitetoolbar__search-wrap"><div class="sitetoolbar__search-content"><button class="sitetoolbar__search-toggle" type="button"></button><form class="sitetoolbar__search" method="GET" action="/search"><div class="sitetoolbar__search-input"><div class="text-input"><input class="text-input__control" name="query" placeholder="在 Javascript.info 网站中搜索" required="required" type="text"></div><button class="sitetoolbar__find" type="submit">搜索</button></div></form></div></div></div><div class="tablet-menu"><div class="tablet-menu__line"><div class="tablet-menu__content"><form class="tablet-menu-search" action="/search/"><input class="tablet-menu-search__input" type="search" name="query" placeholder="在教程中搜索" required="required"><button class="tablet-menu-search__button" type="submit" name="type" value="articles">搜索</button></form></div></div><div class="tablet-menu__line"><div class="tablet-menu__content"><a class="map" href="../tutorial/map/index.html" data-action="tutorial-map"><span class="map__text">教程路线图</span></a></div></div><div class="tablet-menu__line"><div class="tablet-menu__content"><div class="theme-changer theme-changer_tablet-menu theme-changer_has-label"><label class="theme-changer__label" for="theme-changer-input-tablet" data-tooltip="Change theme"><input class="theme-changer__input" type="checkbox" id="theme-changer-input-tablet" data-theme-changer="data-theme-changer"><span class="theme-changer__icon theme-changer__icon_light-theme"></span><span class="theme-changer__icon theme-changer__icon_dark-theme"></span><span class="theme-changer__label-text theme-changer__label-text_light-theme">Light theme</span><span class="theme-changer__label-text theme-changer__label-text_dark-theme">Dark theme</span></label></div></div></div><div class="tablet-menu__line"><div class="tablet-menu__content"><div class="share-icons"><span class="share-icons__title">分享</span><a class="share share_tw" href="https://twitter.com/share?url=https%3A%2F%2Fzh.javascript.info%2Fclass-inheritance" rel="nofollow"></a><a class="share share_fb" href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fzh.javascript.info%2Fclass-inheritance" rel="nofollow"></a></div></div></div><div class="tablet-menu__line"><div class="tablet-menu__content"><select class="tablet-menu__nav input-select input-select input-select_small" onchange="if(this.value) window.location.href=this.value"><option value="https://ar.javascript.info/class-inheritance">عربي</option><option value="https://javascript.info/class-inheritance">English</option><option value="https://es.javascript.info/class-inheritance">Español</option><option value="https://fr.javascript.info/class-inheritance">Français</option><option value="https://id.javascript.info/class-inheritance">Indonesia</option><option value="https://it.javascript.info/class-inheritance">Italiano</option><option value="https://ja.javascript.info/class-inheritance">日本語</option><option value="https://ko.javascript.info/class-inheritance">한국어</option><option value="https://learn.javascript.ru/class-inheritance">Русский</option><option value="https://tr.javascript.info/class-inheritance">Türkçe</option><option value="https://uk.javascript.info/class-inheritance">Українська</option><option value="https://zh.javascript.info/class-inheritance" selected>简体中文</option></select></div></div></div><progress class="tutorial-progress" data-sticky value="67" max="92" data-tooltip="第 67/92 节"></progress></div><div class="page page_sidebar_on page_inner_padding"><script>if(localStorage.noSidebar){document.querySelector(".page").classList.remove("page_sidebar_on");let e=document.querySelector(".page-wrapper");e&&e.classList.remove("page-wrapper_sidebar_on")}setTimeout(function(){document.querySelector(".page").classList.add("page_sidebar-animation-on")});</script><div class="page__inner"><main class="main main_width-limit"><header class="main__header"><div class="main__header-inner"><div class="main__header-group"><ol class="breadcrumbs"><li class="breadcrumbs__item breadcrumbs__item_home"><a class="breadcrumbs__link" href="../index.html"><span class="breadcrumbs__hidden-text">教程</span></a></li><li class="breadcrumbs__item" id="breadcrumb-1"><a class="breadcrumbs__link" href="../js/index.html"><span>JavaScript 编程语言</span></a></li><li class="breadcrumbs__item" id="breadcrumb-2"><a class="breadcrumbs__link" href="../classes/index.html"><span>类</span></a></li><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"教程","item":"https://zh.javascript.info/"},{"@type":"ListItem","position":2,"name":"JavaScript 编程语言","item":"https://zh.javascript.info/js"},{"@type":"ListItem","position":3,"name":"类","item":"https://zh.javascript.info/classes"}]}</script></ol><div class="updated-at" data-tooltip="最后修改在 13日 二月 2022"><div class="updated-at__content">13日 二月 2022</div></div></div><h1 class="main__header-title">类继承</h1></div></header><div class="content"><article class="formatted" itemscope itemtype="http://schema.org/TechArticle"><meta itemprop="name" content="类继承"><div itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="email" content="iliakan@gmail.com"><meta itemprop="name" content="Ilya Kantor"></div><div itemprop="articleBody"><p>类继承是一个类扩展另一个类的一种方式。</p>
<p>因此，我们可以在现有功能之上创建新功能。</p>
<h2><a class="main__anchor" name="extends-guan-jian-zi" href="#extends-guan-jian-zi">“extends” 关键字</a></h2><p>假设我们有 class <code>Animal</code>：</p>
<div id="lp3wqw6lbf" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  run(speed) {
    this.speed = speed;
    alert(`${this.name} runs with speed ${this.speed}.`);
  }
  stop() {
    this.speed = 0;
    alert(`${this.name} stands still.`);
  }
}

let animal = new Animal(&quot;My animal&quot;);</code></pre>
        </div>
      </div>
      
      </div><p>这是我们对对象 <code>animal</code> 和 class <code>Animal</code> 的图形化表示：</p>
<figure><div class="image" style="width:449px">
      <div class="image__ratio" style="padding-top:46.99331848552338%"></div>
      <object type="image/svg+xml" data="../article/class-inheritance/rabbit-animal-independent-animal.svg" width="449" height="211" class="image__image" data-use-theme>
        <img src="../article/class-inheritance/rabbit-animal-independent-animal.svg" alt width="449" height="211">
      </object>
      </div></figure><p>……然后我们想创建另一个 <code>class Rabbit</code>：</p>
<p>因为 rabbits 是 animals，所以 class <code>Rabbit</code> 应该是基于 class <code>Animal</code> 的，可以访问 animal 的方法，以便 rabbits 可以做“一般”动物可以做的事儿。</p>
<p>扩展另一个类的语法是：<code>class Child extends Parent</code>。</p>
<p>让我们创建一个继承自 <code>Animal</code> 的 <code>class Rabbit</code>：</p>
<div id="st201lvcw5" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:0,&quot;end&quot;:0}]">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>class Rabbit extends Animal {
  hide() {
    alert(`${this.name} hides!`);
  }
}

let rabbit = new Rabbit(&quot;White Rabbit&quot;);

rabbit.run(5); // White Rabbit runs with speed 5.
rabbit.hide(); // White Rabbit hides!</code></pre>
        </div>
      </div>
      
      </div><p>Class <code>Rabbit</code> 的对象可以访问例如 <code>rabbit.hide()</code> 等 <code>Rabbit</code> 的方法，还可以访问例如 <code>rabbit.run()</code> 等 <code>Animal</code> 的方法。</p>
<p>在内部，关键字 <code>extends</code> 使用了很好的旧的原型机制进行工作。它将 <code>Rabbit.prototype.[[Prototype]]</code> 设置为 <code>Animal.prototype</code>。所以，如果在 <code>Rabbit.prototype</code> 中找不到一个方法，JavaScript 就会从 <code>Animal.prototype</code> 中获取该方法。</p>
<figure><div class="image" style="width:560px">
      <div class="image__ratio" style="padding-top:56.42857142857143%"></div>
      <object type="image/svg+xml" data="../article/class-inheritance/animal-rabbit-extends.svg" width="560" height="316" class="image__image" data-use-theme>
        <img src="../article/class-inheritance/animal-rabbit-extends.svg" alt width="560" height="316">
      </object>
      </div></figure><p>例如，要查找 <code>rabbit.run</code> 方法，JavaScript 引擎会进行如下检查（如图所示从下到上）：</p>
<ol>
<li>查找对象 <code>rabbit</code>（没有 <code>run</code>）。</li>
<li>查找它的原型，即 <code>Rabbit.prototype</code>（有 <code>hide</code>，但没有 <code>run</code>）。</li>
<li>查找它的原型，即（由于 <code>extends</code>）<code>Animal.prototype</code>，在这儿找到了 <code>run</code> 方法。</li>
</ol>
<p>我们可以回忆一下 <a href="../native-prototypes/index.html">原生的原型</a> 这一章的内容，JavaScript 内建对象同样也使用原型继承。例如，<code>Date.prototype.[[Prototype]]</code> 是 <code>Object.prototype</code>。这就是为什么日期可以访问通用对象的方法。</p>
<div class="important important_smart">
            <div class="important__header"><span class="important__type">在 <code>extends</code> 后允许任意表达式</span></div>
            <div class="important__content"><p>类语法不仅允许指定一个类，在 <code>extends</code> 后可以指定任意表达式。</p>
<p>例如，一个生成父类的函数调用：</p>
<div id="a5ygyd6ho3" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:6,&quot;end&quot;:6}]">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="运行" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="在沙箱中打开" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function f(phrase) {
  return class {
    sayHi() { alert(phrase); }
  };
}

class User extends f(&quot;Hello&quot;) {}

new User().sayHi(); // Hello</code></pre>
        </div>
      </div>
      
      </div><p>这里 <code>class User</code> 继承自 <code>f(&quot;Hello&quot;)</code> 的结果。</p>
<p>这对于高级编程模式，例如当我们根据许多条件使用函数生成类，并继承它们时来说可能很有用。</p>
</div></div>
<h2><a class="main__anchor" name="zhong-xie-fang-fa" href="#zhong-xie-fang-fa">重写方法</a></h2><p>现在，让我们继续前行并尝试重写一个方法。默认情况下，所有未在 <code>class Rabbit</code> 中指定的方法均从 <code>class Animal</code> 中直接获取。</p>
<p>但是如果我们在 <code>Rabbit</code> 中指定了我们自己的方法，例如 <code>stop()</code>，那么将会使用它：</p>
<div id="vddtbnmfp8" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>class Rabbit extends Animal {
  stop() {
    // ……现在这个将会被用作 rabbit.stop()
    // 而不是来自于 class Animal 的 stop()
  }
}</code></pre>
        </div>
      </div>
      
      </div><p>但是通常来说，我们不希望完全替换父类的方法，而是希望在父类方法的基础上进行调整或扩展其功能。我们在我们的方法中做一些事儿，但是在它之前或之后或在过程中会调用父类方法。</p>
<p>Class 为此提供了 <code>&quot;super&quot;</code> 关键字。</p>
<ul>
<li>执行 <code>super.method(...)</code> 来调用一个父类方法。</li>
<li>执行 <code>super(...)</code> 来调用一个父类 constructor（只能在我们的 constructor 中）。</li>
</ul>
<p>例如，让我们的 rabbit 在停下来的时候自动 hide：</p>
<div id="e0tkwiyx1l" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:24,&quot;end&quot;:27}]">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="运行" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="在沙箱中打开" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>class Animal {

  constructor(name) {
    this.speed = 0;
    this.name = name;
  }

  run(speed) {
    this.speed = speed;
    alert(`${this.name} runs with speed ${this.speed}.`);
  }

  stop() {
    this.speed = 0;
    alert(`${this.name} stands still.`);
  }

}

class Rabbit extends Animal {
  hide() {
    alert(`${this.name} hides!`);
  }

  stop() {
    super.stop(); // 调用父类的 stop
    this.hide(); // 然后 hide
  }
}

let rabbit = new Rabbit(&quot;White Rabbit&quot;);

rabbit.run(5); // White Rabbit runs with speed 5.
rabbit.stop(); // White Rabbit stands still. White Rabbit hides!</code></pre>
        </div>
      </div>
      
      </div><p>现在，<code>Rabbit</code> 在执行过程中调用父类的 <code>super.stop()</code> 方法，所以 <code>Rabbit</code> 也具有了 <code>stop</code> 方法。</p>
<div class="important important_smart">
            <div class="important__header"><span class="important__type">箭头函数没有 <code>super</code></span></div>
            <div class="important__content"><p>正如我们在 <a href="../arrow-functions/index.html">深入理解箭头函数</a> 一章中所提到的，箭头函数没有 <code>super</code>。</p>
<p>如果被访问，它会从外部函数获取。例如：</p>
<div id="f3q359nbaj" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>class Rabbit extends Animal {
  stop() {
    setTimeout(() =&gt; super.stop(), 1000); // 1 秒后调用父类的 stop
  }
}</code></pre>
        </div>
      </div>
      
      </div><p>箭头函数中的 <code>super</code> 与 <code>stop()</code> 中的是一样的，所以它能按预期工作。如果我们在这里指定一个“普通”函数，那么将会抛出错误：</p>
<div id="l38jx6tqm3" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>// 意料之外的 super
setTimeout(function() { super.stop() }, 1000);</code></pre>
        </div>
      </div>
      
      </div></div></div>
<h2><a class="main__anchor" name="zhong-xie-constructor" href="#zhong-xie-constructor">重写 constructor</a></h2><p>对于重写 constructor 来说，则有点棘手。</p>
<p>到目前为止，<code>Rabbit</code> 还没有自己的 <code>constructor</code>。</p>
<p>根据 <a href="https://tc39.github.io/ecma262/#sec-runtime-semantics-classdefinitionevaluation">规范</a>，如果一个类扩展了另一个类并且没有 <code>constructor</code>，那么将生成下面这样的“空” <code>constructor</code>：</p>
<div id="z62t2d4cm1" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:2,&quot;end&quot;:4}]">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>class Rabbit extends Animal {
  // 为没有自己的 constructor 的扩展类生成的
  constructor(...args) {
    super(...args);
  }
}</code></pre>
        </div>
      </div>
      
      </div><p>正如我们所看到的，它调用了父类的 <code>constructor</code>，并传递了所有的参数。如果我们没有写自己的 constructor，就会出现这种情况。</p>
<p>现在，我们给 <code>Rabbit</code> 添加一个自定义的 constructor。除了 <code>name</code> 之外，它还会指定 <code>earLength</code>。</p>
<div id="o5ecdll65u" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:19,&quot;end&quot;:20},{&quot;start&quot;:10,&quot;end&quot;:14}]">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="运行" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="在沙箱中打开" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  // ...
}

class Rabbit extends Animal {

  constructor(name, earLength) {
    this.speed = 0;
    this.name = name;
    this.earLength = earLength;
  }

  // ...
}

// 不工作！
let rabbit = new Rabbit(&quot;White Rabbit&quot;, 10); // Error: this is not defined.</code></pre>
        </div>
      </div>
      
      </div><p>哎呦！我们得到了一个报错。现在我们没法新建 rabbit。是什么地方出错了？</p>
<p>简短的解释是：</p>
<p><strong>继承类的 constructor 必须调用 <code>super(...)</code>，并且 (!) 一定要在使用 <code>this</code> 之前调用。</strong></p>
<p>……但这是为什么呢？这里发生了什么？确实，这个要求看起来很奇怪。</p>
<p>当然，本文会给出一个解释。让我们深入细节，这样你就可以真正地理解发生了什么。</p>
<p>在 JavaScript 中，继承类（所谓的“派生构造器”，英文为 “derived constructor”）的构造函数与其他函数之间是有区别的。派生构造器具有特殊的内部属性 <code>[[ConstructorKind]]:&quot;derived&quot;</code>。这是一个特殊的内部标签。</p>
<p>该标签会影响它的 <code>new</code> 行为：</p>
<ul>
<li>当通过 <code>new</code> 执行一个常规函数时，它将创建一个空对象，并将这个空对象赋值给 <code>this</code>。</li>
<li>但是当继承的 constructor 执行时，它不会执行此操作。它期望父类的 constructor 来完成这项工作。</li>
</ul>
<p>因此，派生的 constructor 必须调用 <code>super</code> 才能执行其父类（base）的 constructor，否则 <code>this</code> 指向的那个对象将不会被创建。并且我们会收到一个报错。</p>
<p>为了让 <code>Rabbit</code> 的 constructor 可以工作，它需要在使用 <code>this</code> 之前调用 <code>super()</code>，就像下面这样：</p>
<div id="esw1dus01a" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:20,&quot;end&quot;:23},{&quot;start&quot;:13,&quot;end&quot;:13}]">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="运行" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="在沙箱中打开" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>class Animal {

  constructor(name) {
    this.speed = 0;
    this.name = name;
  }

  // ...
}

class Rabbit extends Animal {

  constructor(name, earLength) {
    super(name);
    this.earLength = earLength;
  }

  // ...
}

// 现在可以了
let rabbit = new Rabbit(&quot;White Rabbit&quot;, 10);
alert(rabbit.name); // White Rabbit
alert(rabbit.earLength); // 10</code></pre>
        </div>
      </div>
      
      </div><h3><a class="main__anchor" name="zhong-xie-lei-zi-duan-yi-ge-ji-shou-de-zhu-yi-yao-dian" href="#zhong-xie-lei-zi-duan-yi-ge-ji-shou-de-zhu-yi-yao-dian">重写类字段: 一个棘手的注意要点</a></h3><div class="important important_warn">
            <div class="important__header"><span class="important__type">高阶要点</span></div>
            <div class="important__content"><p>这个要点假设你对类已经有了一定的经验，或许是在其他编程语言中。</p>
<p>这里提供了一个更好的视角来窥探这门语言，且解释了它的行为为什么可能会是 bugs 的来源(但不是非常频繁)。</p>
<p>如果你发现这难以理解，什么都别管，继续往下阅读，之后有机会再回来看。</p>
</div></div>
<p>我们不仅可以重写方法，还可以重写类字段。</p>
<p>不过，当我们访问在父类构造器中的一个被重写的字段时，这里会有一个诡异的行为，这与绝大多数其他编程语言都很不一样。</p>
<p>请思考此示例：</p>
<div id="dhn2lir646" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:13,&quot;end&quot;:13}]">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="运行" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="在沙箱中打开" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>class Animal {
  name = 'animal';

  constructor() {
    alert(this.name); // (*)
  }
}

class Rabbit extends Animal {
  name = 'rabbit';
}

new Animal(); // animal
new Rabbit(); // animal</code></pre>
        </div>
      </div>
      
      </div><p>这里，<code>Rabbit</code> 继承自 <code>Animal</code>，并且用它自己的值重写了 <code>name</code> 字段。</p>
<p>因为 <code>Rabbit</code> 中没有自己的构造器，所以 <code>Animal</code> 的构造器被调用了。</p>
<p>有趣的是在这两种情况下：<code>new Animal()</code> 和 <code>new Rabbit()</code>，在 <code>(*)</code> 行的 <code>alert</code> 都打印了 <code>animal</code>。</p>
<p><strong>换句话说，父类构造器总是会使用它自己字段的值，而不是被重写的那一个。</strong></p>
<p>古怪的是什么呢？</p>
<p>如果这还不清楚，那么让我们用方法来进行比较。</p>
<p>这里是相同的代码，但是我们调用 <code>this.showName()</code> 方法而不是 <code>this.name</code> 字段：</p>
<div id="hclq27je9l" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:17,&quot;end&quot;:17}]">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="运行" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="在沙箱中打开" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>class Animal {
  showName() {  // 而不是 this.name = 'animal'
    alert('animal');
  }

  constructor() {
    this.showName(); // 而不是 alert(this.name);
  }
}

class Rabbit extends Animal {
  showName() {
    alert('rabbit');
  }
}

new Animal(); // animal
new Rabbit(); // rabbit</code></pre>
        </div>
      </div>
      
      </div><p>请注意：这时的输出是不同的。</p>
<p>这才是我们本来所期待的结果。当父类构造器在派生的类中被调用时，它会使用被重写的方法。</p>
<p>……但对于类字段并非如此。正如前文所述，父类构造器总是使用父类的字段。</p>
<p>这里为什么会有这样的区别呢？</p>
<p>实际上，原因在于字段初始化的顺序。类字段是这样初始化的：</p>
<ul>
<li>对于基类（还未继承任何东西的那种），在构造函数调用前初始化。</li>
<li>对于派生类，在 <code>super()</code> 后立刻初始化。</li>
</ul>
<p>在我们的例子中，<code>Rabbit</code> 是派生类，里面没有 <code>constructor()</code>。正如先前所说，这相当于一个里面只有 <code>super(...args)</code> 的空构造器。</p>
<p>所以，<code>new Rabbit()</code> 调用了 <code>super()</code>，因此它执行了父类构造器，并且（根据派生类规则）只有在此之后，它的类字段才被初始化。在父类构造器被执行的时候，<code>Rabbit</code> 还没有自己的类字段，这就是为什么 <code>Animal</code> 类字段被使用了。</p>
<p>这种字段与方法之间微妙的区别只特定于 JavaScript。</p>
<p>幸运的是，这种行为仅在一个被重写的字段被父类构造器使用时才会显现出来。接下来它会发生的东西可能就比较难理解了，所以我们要在这里对此行为进行解释。</p>
<p>如果出问题了，我们可以通过使用方法或者 getter/setter 替代类字段，来修复这个问题。</p>
<h2><a class="main__anchor" name="shen-ru-nei-bu-tan-jiu-he-homeobject" href="#shen-ru-nei-bu-tan-jiu-he-homeobject">深入：内部探究和 [[HomeObject]]</a></h2><div class="important important_warn">
            <div class="important__header"><span class="important__type">进阶内容</span></div>
            <div class="important__content"><p>如果你是第一次阅读本教程，那么则可以跳过本节。</p>
<p>这是关于继承和 <code>super</code> 背后的内部机制。</p>
</div></div>
<p>让我们更深入地研究 <code>super</code>。我们将在这个过程中发现一些有趣的事儿。</p>
<p>首先要说的是，从我们迄今为止学到的知识来看，<code>super</code> 是不可能运行的。</p>
<p>的确是这样，让我们问问自己，以技术的角度它是如何工作的？当一个对象方法执行时，它会将当前对象作为 <code>this</code>。随后如果我们调用 <code>super.method()</code>，那么引擎需要从当前对象的原型中获取 <code>method</code>。但这是怎么做到的？</p>
<p>这个任务看起来是挺容易的，但其实并不简单。引擎知道当前对象的 <code>this</code>，所以它可以获取父 <code>method</code> 作为 <code>this.__proto__.method</code>。不幸的是，这个“天真”的解决方法是行不通的。</p>
<p>让我们演示一下这个问题。简单起见，我们使用普通对象而不使用类。</p>
<p>如果你不想知道更多的细节知识，你可以跳过此部分，并转到下面的 <code>[[HomeObject]]</code> 小节。这没关系的。但如果你感兴趣，想学习更深入的知识，那就继续阅读吧。</p>
<p>在下面的例子中，<code>rabbit.__proto__ = animal</code>。现在让我们尝试一下：在 <code>rabbit.eat()</code> 我们将会使用 <code>this.__proto__</code> 调用 <code>animal.eat()</code>：</p>
<div id="bwqmzlto7r" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:11,&quot;end&quot;:12}]">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="运行" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="在沙箱中打开" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let animal = {
  name: &quot;Animal&quot;,
  eat() {
    alert(`${this.name} eats.`);
  }
};

let rabbit = {
  __proto__: animal,
  name: &quot;Rabbit&quot;,
  eat() {
    // 这就是 super.eat() 可以大概工作的方式
    this.__proto__.eat.call(this); // (*)
  }
};

rabbit.eat(); // Rabbit eats.</code></pre>
        </div>
      </div>
      
      </div><p>在 <code>(*)</code> 这一行，我们从原型（<code>animal</code>）中获取 <code>eat</code>，并在当前对象的上下文中调用它。请注意，<code>.call(this)</code> 在这里非常重要，因为简单的调用 <code>this.__proto__.eat()</code> 将在原型的上下文中执行 <code>eat</code>，而非当前对象。</p>
<p>在上面的代码中，它确实按照了期望运行：我们获得了正确的 <code>alert</code>。</p>
<p>现在，让我们在原型链上再添加一个对象。我们将看到这件事是如何被打破的：</p>
<div id="cb9c7vqelf" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:23,&quot;end&quot;:23}]">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="运行" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="在沙箱中打开" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let animal = {
  name: &quot;Animal&quot;,
  eat() {
    alert(`${this.name} eats.`);
  }
};

let rabbit = {
  __proto__: animal,
  eat() {
    // ...bounce around rabbit-style and call parent (animal) method
    this.__proto__.eat.call(this); // (*)
  }
};

let longEar = {
  __proto__: rabbit,
  eat() {
    // ...do something with long ears and call parent (rabbit) method
    this.__proto__.eat.call(this); // (**)
  }
};

longEar.eat(); // Error: Maximum call stack size exceeded</code></pre>
        </div>
      </div>
      
      </div><p>代码无法再运行了！我们可以看到，在试图调用 <code>longEar.eat()</code> 时抛出了错误。</p>
<p>原因可能不那么明显，但是如果我们跟踪 <code>longEar.eat()</code> 调用，就可以发现原因。在 <code>(*)</code> 和 <code>(**)</code> 这两行中，<code>this</code> 的值都是当前对象（<code>longEar</code>）。这是至关重要的一点：所有的对象方法都将当前对象作为 <code>this</code>，而非原型或其他什么东西。</p>
<p>因此，在 <code>(*)</code> 和 <code>(**)</code> 这两行中，<code>this.__proto__</code> 的值是完全相同的：都是 <code>rabbit</code>。它们俩都调用的是 <code>rabbit.eat</code>，它们在不停地循环调用自己，而不是在原型链上向上寻找方法。</p>
<p>这张图介绍了发生的情况：</p>
<figure><div class="image" style="width:347px">
      <div class="image__ratio" style="padding-top:68.58789625360231%"></div>
      <object type="image/svg+xml" data="../article/class-inheritance/this-super-loop.svg" width="347" height="238" class="image__image" data-use-theme>
        <img src="../article/class-inheritance/this-super-loop.svg" alt width="347" height="238">
      </object>
      </div></figure><ol>
<li>
<p>在 <code>longEar.eat()</code> 中，<code>(**)</code> 这一行调用 <code>rabbit.eat</code> 并为其提供 <code>this=longEar</code>。</p>
<div id="mcu2z2r2zj" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>// 在 longEar.eat() 中我们有 this = longEar
this.__proto__.eat.call(this) // (**)
// 变成了
longEar.__proto__.eat.call(this)
// 也就是
rabbit.eat.call(this);</code></pre>
        </div>
      </div>
      
      </div></li>
<li>
<p>之后在 <code>rabbit.eat</code> 的 <code>(*)</code> 行中，我们希望将函数调用在原型链上向更高层传递，但是 <code>this=longEar</code>，所以 <code>this.__proto__.eat</code> 又是 <code>rabbit.eat</code>！</p>
<div id="so39u6y4ob" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>// 在 rabbit.eat() 中我们依然有 this = longEar
this.__proto__.eat.call(this) // (*)
// 变成了
longEar.__proto__.eat.call(this)
// 或（再一次）
rabbit.eat.call(this);</code></pre>
        </div>
      </div>
      
      </div></li>
<li>
<p>……所以 <code>rabbit.eat</code> 在不停地循环调用自己，因此它无法进一步地提升。</p>
</li>
</ol>
<p>这个问题没法仅仅通过使用 <code>this</code> 来解决。</p>
<h3><a class="main__anchor" name="homeobject" href="#homeobject"><code>[[HomeObject]]</code></a></h3><p>为了提供解决方法，JavaScript 为函数添加了一个特殊的内部属性：<code>[[HomeObject]]</code>。</p>
<p>当一个函数被定义为类或者对象方法时，它的 <code>[[HomeObject]]</code> 属性就成为了该对象。</p>
<p>然后 <code>super</code> 使用它来解析（resolve）父原型及其方法。</p>
<p>让我们看看它是怎么工作的，首先，对于普通对象：</p>
<div id="e1iqrytpar" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:23,&quot;end&quot;:24}]">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="运行" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="在沙箱中打开" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let animal = {
  name: &quot;Animal&quot;,
  eat() {         // animal.eat.[[HomeObject]] == animal
    alert(`${this.name} eats.`);
  }
};

let rabbit = {
  __proto__: animal,
  name: &quot;Rabbit&quot;,
  eat() {         // rabbit.eat.[[HomeObject]] == rabbit
    super.eat();
  }
};

let longEar = {
  __proto__: rabbit,
  name: &quot;Long Ear&quot;,
  eat() {         // longEar.eat.[[HomeObject]] == longEar
    super.eat();
  }
};

// 正确执行
longEar.eat();  // Long Ear eats.</code></pre>
        </div>
      </div>
      
      </div><p>它基于 <code>[[HomeObject]]</code> 运行机制按照预期执行。一个方法，例如 <code>longEar.eat</code>，知道其 <code>[[HomeObject]]</code> 并且从其原型中获取父方法。并没有使用 <code>this</code>。</p>
<h3><a class="main__anchor" name="fang-fa-bing-bu-shi-zi-you-de" href="#fang-fa-bing-bu-shi-zi-you-de">方法并不是“自由”的</a></h3><p>正如我们之前所知道的，函数通常都是“自由”的，并没有绑定到 JavaScript 中的对象。正因如此，它们可以在对象之间复制，并用另外一个 <code>this</code> 调用它。</p>
<p><code>[[HomeObject]]</code> 的存在违反了这个原则，因为方法记住了它们的对象。<code>[[HomeObject]]</code> 不能被更改，所以这个绑定是永久的。</p>
<p>在 JavaScript 语言中 <code>[[HomeObject]]</code> 仅被用于 <code>super</code>。所以，如果一个方法不使用 <code>super</code>，那么我们仍然可以视它为自由的并且可在对象之间复制。但是用了 <code>super</code> 再这样做可能就会出错。</p>
<p>下面是复制后错误的 <code>super</code> 结果的示例：</p>
<div id="g2xt0sur2s" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:26,&quot;end&quot;:26},{&quot;start&quot;:23,&quot;end&quot;:23}]">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="运行" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="在沙箱中打开" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let animal = {
  sayHi() {
    alert(`I'm an animal`);
  }
};

// rabbit 继承自 animal
let rabbit = {
  __proto__: animal,
  sayHi() {
    super.sayHi();
  }
};

let plant = {
  sayHi() {
    alert(&quot;I'm a plant&quot;);
  }
};

// tree 继承自 plant
let tree = {
  __proto__: plant,
  sayHi: rabbit.sayHi // (*)
};

tree.sayHi();  // I'm an animal (?!?)</code></pre>
        </div>
      </div>
      
      </div><p>调用 <code>tree.sayHi()</code> 显示 “I’m an animal”。这绝对是错误的。</p>
<p>原因很简单：</p>
<ul>
<li>在 <code>(*)</code> 行，<code>tree.sayHi</code> 方法是从 <code>rabbit</code> 复制而来。也许我们只是想避免重复代码？</li>
<li>它的 <code>[[HomeObject]]</code> 是 <code>rabbit</code>，因为它是在 <code>rabbit</code> 中创建的。没有办法修改 <code>[[HomeObject]]</code>。</li>
<li><code>tree.sayHi()</code> 内具有 <code>super.sayHi()</code>。它从 <code>rabbit</code> 中上溯，然后从 <code>animal</code> 中获取方法。</li>
</ul>
<p>这是发生的情况示意图：</p>
<figure><div class="image" style="width:395px">
      <div class="image__ratio" style="padding-top:48.60759493670886%"></div>
      <object type="image/svg+xml" data="../article/class-inheritance/super-homeobject-wrong.svg" width="395" height="192" class="image__image" data-use-theme>
        <img src="../article/class-inheritance/super-homeobject-wrong.svg" alt width="395" height="192">
      </object>
      </div></figure><h3><a class="main__anchor" name="fang-fa-bu-shi-han-shu-shu-xing" href="#fang-fa-bu-shi-han-shu-shu-xing">方法，不是函数属性</a></h3><p><code>[[HomeObject]]</code> 是为类和普通对象中的方法定义的。但是对于对象而言，方法必须确切指定为 <code>method()</code>，而不是 <code>&quot;method: function()&quot;</code>。</p>
<p>这个差别对我们来说可能不重要，但是对 JavaScript 来说却非常重要。</p>
<p>在下面的例子中，使用非方法（non-method）语法进行了比较。未设置 <code>[[HomeObject]]</code> 属性，并且继承无效：</p>
<div id="idoubqpiii" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:13,&quot;end&quot;:13}]">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="运行" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="在沙箱中打开" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let animal = {
  eat: function() { // 这里是故意这样写的，而不是 eat() {...
    // ...
  }
};

let rabbit = {
  __proto__: animal,
  eat: function() {
    super.eat();
  }
};

rabbit.eat();  // 错误调用 super（因为这里没有 [[HomeObject]]）</code></pre>
        </div>
      </div>
      
      </div><h2><a class="main__anchor" name="zong-jie" href="#zong-jie">总结</a></h2><ol>
<li>想要扩展一个类：<code>class Child extends Parent</code>：
<ul>
<li>这意味着 <code>Child.prototype.__proto__</code> 将是 <code>Parent.prototype</code>，所以方法会被继承。</li>
</ul>
</li>
<li>重写一个 constructor：
<ul>
<li>在使用 <code>this</code> 之前，我们必须在 <code>Child</code> 的 constructor 中将父 constructor 调用为 <code>super()</code>。</li>
</ul>
</li>
<li>重写一个方法：
<ul>
<li>我们可以在一个 <code>Child</code> 方法中使用 <code>super.method()</code> 来调用 <code>Parent</code> 方法。</li>
</ul>
</li>
<li>内部：
<ul>
<li>方法在内部的 <code>[[HomeObject]]</code> 属性中记住了它们的类/对象。这就是 <code>super</code> 如何解析父方法的。</li>
<li>因此，将一个带有 <code>super</code> 的方法从一个对象复制到另一个对象是不安全的。</li>
</ul>
</li>
</ol>
<p>补充：</p>
<ul>
<li>箭头函数没有自己的 <code>this</code> 或 <code>super</code>，所以它们能融入到就近的上下文中，像透明似的。</li>
</ul>
</div></article><div class="tasks formatted"><h2 class="tasks__title" id="tasks"><a class="tasks__title-anchor main__anchor main__anchor main__anchor_noicon" href="#tasks">任务</a></h2><div class="task tasks__task"><div class="task__header"><div class="task__title-wrap"><h3 class="task__title"><a class="main__anchor" href="#chuang-jian-shi-li-shi-chu-cuo" name="chuang-jian-shi-li-shi-chu-cuo">创建实例时出错</a></h3><a class="task__open-link" href="../task/class-constructor-error/index.html" target="_blank"></a></div><div class="task__header-note"><span class="task__importance" title="任务的重要程度有多高，等级从 1 到 5。">重要程度: 5</span></div><div class="task__content"><div class="task__formatted"><p>这里有一份 <code>Rabbit</code> 扩展 <code>Animal</code> 的代码。</p>
<p>不幸的是，<code>Rabbit</code> 对象无法被创建。是哪里出错了呢？请解决它。</p>
<div id="nbykuzbtv1" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:15,&quot;end&quot;:15}]">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="运行" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="在沙箱中打开" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>class Animal {

  constructor(name) {
    this.name = name;
  }

}

class Rabbit extends Animal {
  constructor(name) {
    this.name = name;
    this.created = Date.now();
  }
}

let rabbit = new Rabbit(&quot;White Rabbit&quot;); // Error: this is not defined
alert(rabbit.name);</code></pre>
        </div>
      </div>
      
      </div></div><button class="task__solution" type="button">解决方案</button><div class="task__answer"><div class="task__answer-content"><div class="formatted"><p>这是因为子类的 constructor 必须调用 <code>super()</code>。</p>
<p>这里是修正后的代码：</p>
<div id="ywb2ye838e" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:15,&quot;end&quot;:15},{&quot;start&quot;:10,&quot;end&quot;:10}]">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="运行" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="在沙箱中打开" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>class Animal {

  constructor(name) {
    this.name = name;
  }

}

class Rabbit extends Animal {
  constructor(name) {
    super(name);
    this.created = Date.now();
  }
}

let rabbit = new Rabbit(&quot;White Rabbit&quot;); // 现在好了
alert(rabbit.name); // White Rabbit</code></pre>
        </div>
      </div>
      
      </div></div></div><button class="close-button task__answer-close" type="button" title="关闭"></button></div></div></div></div><div class="task tasks__task"><div class="task__header"><div class="task__title-wrap"><h3 class="task__title"><a class="main__anchor" href="#kuo-zhan-clock" name="kuo-zhan-clock">扩展 clock</a></h3><a class="task__open-link" href="../task/clock-class-extended/index.html" target="_blank"></a></div><div class="task__header-note"><span class="task__importance" title="任务的重要程度有多高，等级从 1 到 5。">重要程度: 5</span></div><div class="task__content"><div class="task__formatted"><p>我们获得了一个 <code>Clock</code> 类。到目前为止，它每秒都会打印一次时间。</p>
<div id="o6xb8tsbht" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>class Clock {
  constructor({ template }) {
    this.template = template;
  }

  render() {
    let date = new Date();

    let hours = date.getHours();
    if (hours &lt; 10) hours = '0' + hours;

    let mins = date.getMinutes();
    if (mins &lt; 10) mins = '0' + mins;

    let secs = date.getSeconds();
    if (secs &lt; 10) secs = '0' + secs;

    let output = this.template
      .replace('h', hours)
      .replace('m', mins)
      .replace('s', secs);

    console.log(output);
  }

  stop() {
    clearInterval(this.timer);
  }

  start() {
    this.render();
    this.timer = setInterval(() =&gt; this.render(), 1000);
  }
}</code></pre>
        </div>
      </div>
      
      </div><p>创建一个继承自 <code>Clock</code> 的新的类 <code>ExtendedClock</code>，并添加参数 <code>precision</code> — 每次 “ticks” 之间间隔的毫秒数，默认是 <code>1000</code>（1 秒）。</p>
<ul>
<li>你的代码应该在 <code>extended-clock.js</code> 文件里。</li>
<li>不要修改原有的 <code>clock.js</code>。请扩展它。</li>
</ul>
<p><a href="https://plnkr.co/edit/Wvydd38tp2SEAI7k?p=preview" target="_blank" data-plunk-id="Wvydd38tp2SEAI7k">打开一个任务沙箱。</a></p></div><button class="task__solution" type="button">解决方案</button><div class="task__answer"><div class="task__answer-content"><div class="formatted"><div id="q9lt06ynpz" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>class ExtendedClock extends Clock {
  constructor(options) {
    super(options);
    let { precision = 1000 } = options;
    this.precision = precision;
  }

  start() {
    this.render();
    this.timer = setInterval(() =&gt; this.render(), this.precision);
  }
};</code></pre>
        </div>
      </div>
      
      </div><p><a href="https://plnkr.co/edit/xfIMTlbQ40DZIQDu?p=preview" target="_blank" data-plunk-id="xfIMTlbQ40DZIQDu">使用沙箱打开解决方案。</a></p></div></div><button class="close-button task__answer-close" type="button" title="关闭"></button></div></div></div></div></div></div><div class="page__nav-wrap"><a class="page__nav page__nav_prev" href="../class/index.html" data-tooltip="Class 基本语法"><span class="page__nav-text"><span class="page__nav-text-shortcut"></span></span><span class="page__nav-text-alternate">上一节</span></a><a class="page__nav page__nav_next" href="../static-properties-methods/index.html" data-tooltip="静态属性和静态方法"><span class="page__nav-text"><span class="page__nav-text-shortcut"></span></span><span class="page__nav-text-alternate">下一节</span></a></div><div class="article-tablet-foot tablet-only"><div class="article-tablet-foot__layout"><div class="share-icons"><span class="share-icons__title">分享</span><a class="share share_tw" href="https://twitter.com/share?url=https%3A%2F%2Fzh.javascript.info%2Fclass-inheritance" rel="nofollow"></a><a class="share share_fb" href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fzh.javascript.info%2Fclass-inheritance" rel="nofollow"></a></div><div class="article-tablet-foot__map"><a class="map" href="../tutorial/map/index.html" data-action="tutorial-map"><span class="map__text">教程路线图</span></a></div></div></div><div class="comments formatted" id="comments"><div class="comments__header"><h2 class="comments__header-title"><a href="#comments" name="comments">评论</a></h2><div class="comments__read-before"><span class="comments__read-before-link">在评论之前先阅读本内容…</span><div class="comments__read-before-popup"><div class="comments__read-before-popup-i"><ul><li>如果你发现教程有错误，或者有其他需要修改和提升的地方 — 请 <a href="https://github.com/javascript-tutorial/zh.javascript.info/issues">提交一个 GitHub issue</a> 或 pull request，而不是在这评论。</li><li>如果你对教程的内容有不理解的地方 — 请详细说明。</li><li>使用 <code>&lt;code&gt;</code> 标签插入只有几个词的代码，插入多行代码可以使用 <code>&lt;pre&gt;</code> 标签，对于超过 10 行的代码，建议你使用沙箱（<a href="https://plnkr.co/edit/?p=preview">plnkr</a>，<a href="https://jsbin.com">JSBin</a>，<a href="http://codepen.io">codepen</a>…）</li></ul></div></div></div></div><div id="disqus_thread"></div><script>var disqus_config = function() { if (!this.page) this.page = {}; Object.assign(this.page, {"url":"https:\/\/zh.javascript.info\/class-inheritance","identifier":"\/class-inheritance"}); };</script><script>var disqus_shortname = "zh-javascript-info";</script><script>var disqus_enabled = true;</script></div></main></div><div class="sidebar page__sidebar sidebar sidebar_sticky-footer"><button class="sidebar__toggle" data-sidebar-toggle></button><a class="map" href="../tutorial/map/index.html" data-action="tutorial-map" data-tooltip="教程路线图"></a><div class="sidebar__inner"><div class="sidebar__content"><div class="sidebar__section"><h4 class="sidebar__section-title">章节</h4><nav class="sidebar__navigation"><ul class="sidebar__navigation-links"><li class="sidebar__navigation-link"><a class="sidebar__link" href="../classes/index.html">类</a></li></ul></nav></div><div class="sidebar__section"><h4 class="sidebar__section-title">课程导航</h4><nav class="sidebar__navigation"><ul class="sidebar__navigation-links"><li class="sidebar__navigation-link"><a class="sidebar__link" href="#extends-guan-jian-zi">“extends” 关键字</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="#zhong-xie-fang-fa">重写方法</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="#zhong-xie-constructor">重写 constructor</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="#shen-ru-nei-bu-tan-jiu-he-homeobject">深入：内部探究和 [[HomeObject]]</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="#zong-jie">总结</a></li></ul></nav></div><div class="sidebar__section"><nav class="sidebar__navigation"><ul class="sidebar__navigation-links"><li class="sidebar__navigation-link"><a class="sidebar__link" href="#tasks">任务 (2)</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="#comments">评论</a></li></ul></nav></div><div class="sidebar__section"><div class="sidebar__section-title">分享</div><a class="share share_tw sidebar__share" href="https://twitter.com/share?url=https%3A%2F%2Fzh.javascript.info%2Fclass-inheritance" rel="nofollow"></a><a class="share share_fb sidebar__share" href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p[url]=https%3A%2F%2Fzh.javascript.info%2Fclass-inheritance" rel="nofollow"></a></div><div class="sidebar__section"><a class="sidebar__link" href="https://github.com/javascript-tutorial/zh.javascript.info/blob/master/1-js/09-classes/02-class-inheritance" rel="nofollow">在 GitHub 上编辑</a></div></div></div></div></div></div><div class="page-footer"><ul class="page-footer__list"><li class="page-footer__item page-footer__item_copy">©&nbsp;2007—2022&nbsp; Ilya Kantor</li><li class="page-footer__item page-footer__item_about"><a class="page-footer__link" href="../about/index.html">关于本项目</a></li><li class="page-footer__item page-footer__item_contact"><a class="page-footer__link" href="../about/index.html#contact-us">联系我们</a></li></ul></div></body></html>